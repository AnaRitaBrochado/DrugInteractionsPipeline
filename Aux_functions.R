#List of functions defined here

#======================== Basics ====================

#This function takes an object (x) and a vector (v) and returns the first position of x in v, when x is found in v. 
grep_uniq <- function(x,v)
{
  match_vec = grep(x, v, fixed = TRUE)
  uniq_match = c()
  
  #To make sure that well_index points to the exact one and only one well
  if (length(match_vec) > 0)
  {
    for(i in 1:length(match_vec))
    {
      match_vec_temp = match_vec[i]
      if (nchar(match_vec_temp) > 0 && x == v[match_vec_temp])
      {uniq_match = c(uniq_match, match_vec_temp)}
    }
  }
  return(uniq_match[1])
}

grep_exact <- function(x,v)
{
  match_vec = grep(x, v, fixed = TRUE)
  uniq_match = c()
  
  #To make sure that well_index points to the exact one and only one well
  if (length(match_vec) > 0)
  {
    for(i in 1:length(match_vec))
    {
      match_vec_temp = match_vec[i]
      if (nchar(match_vec_temp) > 0 && x == v[match_vec_temp])
      {uniq_match = c(uniq_match, match_vec_temp)}
    }
  }
  return(uniq_match)
}

vec2str <- function(vec, separator = " ")
{
  str = c()
  if(length(vec)>1)
  {
    for(o in 1:(length(vec)-1))
    {
      str = paste0(str,vec[o], sep = separator, collapse=NULL)
    }
  }  
  #if (length(vec)>0)
{str = paste0(str,vec[length(vec)], sep = "", collapse=NULL)}
  return(str)
}

quadr <- function(quad,dataset)  #NEW
{
  all_wells = names(dataset)[2:length(dataset)]
  sel_wells = c()

  nr_rows = 16
  nr_cols = length(all_wells)/nr_rows
  c = 1
  for(r in 1:nr_rows)
  {
    while(c <= (nr_cols*r))
    {
      if(quad == 1 && odd(r) && odd(c))
      {sel_wells = c(sel_wells,all_wells[c])}
      
      if(quad == 2 && odd(r) && even(c))
      {sel_wells = c(sel_wells,all_wells[c])}
      
      if(quad == 3 && even(r) && odd(c))
      {sel_wells = c(sel_wells,all_wells[c])}
      
      if(quad == 4 && even(r) && even(c))
      {sel_wells = c(sel_wells,all_wells[c])}
      
      c = c+1
    }
      
  }
  
  red_dataset = Red_dataset(dataset,sel_wells)
  return(red_dataset)
}

#Function returns a vector of 2 integers, ready to be the dimentions of a par
dimPar <- function(x,y)
{
  #x is the number of plots to be made
  #y is the number of the columns of the par
  if(x <= y)
  {
    nr_cols = x
    nr_rows = 1
  } else
  {
    if(x > y)
    {
      nr_cols = y
      nr_rows = ceiling(x/y)
    }
  }
  
  if (x == 96)
  {
    nr_cols = 12
    nr_rows = 8
  }
  
  c(nr_rows,nr_cols)
}

panel.empty <- function(x,y)
{
  xx_coord = max(x)/2
  yy_coord = max(y)/2
  text(xx_coord, yy_coord, "white", col = "white")
}

panel.cor <- function(x, y, digits = 2, prefix = "", cex.cor, ...)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  r <- abs(cor(x, y,use="complete.obs"))
  txt <- format(c(r, 0.123456789), digits = digits)[1]
  txt <- paste0(prefix, txt)
  if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
  text(0.5, 0.5, txt, cex = cex.cor * r)
}

quantile995 = function(x)
{
  y = quantile(x,probs = 0.995)[[1]]
  return(y)
}

quantile95 = function(x)
{
  y = quantile(x,probs = 0.95)[[1]]
  return(y)
}

Red_dataset <- function(dataset, sel_wells)
{
  red_dataset = as.vector(dataset[1])
  for (well in 1:length(sel_wells))
  {
    well_name <- sel_wells[well]
    well_index <- grep_uniq(well_name,names(dataset))
    red_dataset <- cbind(red_dataset,dataset[well_index])
  }
  return (red_dataset)
}  

get_strain <- function(well_name,map_file_path)
{
  plt_map = read.table(map_file_path, header=TRUE, sep="\t", na.strings="NA", dec=".", strip.white=TRUE)
  well_index = grep_uniq(well_name, as.vector(plt_map[[1]]))
  well_strain = plt_map[[well_index,2]]
  
  return(well_strain)
}

#Ext_96plates recieves a path to tab delimited file as generated by SofMaxPro Report and generates as many files as plates(families) contained on the original files.
#the secound output is the name of the outputing directory
#The Data is distributed according to PlateID (=family). Files are also named after PlateID.

Plot_96plates <- function(dataset,sel_wells, map_file_path, full_plate = FALSE, time_window = c(0,14), growth_window = c(-0.1,0.6))
{
  #============================ Read the Plate Map ================================#
  
  plt_map = read.table(map_file_path, header=TRUE, sep="\t", na.strings="NA", dec=".", strip.white=TRUE)
  
  #=================================== Opening Par & selecting data =============================================#
  
  if (full_plate == TRUE)
  {sel_wells =  names(dataset)[2:length(dataset)]}
  
  if (full_plate == FALSE)
  {red_dataset = Red_dataset(dataset,sel_wells)}    
  else {red_dataset = dataset}
  
  xData = as.numeric(as.vector(red_dataset[[1]]))
  
  par(mfrow=dimPar(length(sel_wells),4), mar = c(0.5,0.5,0.5,0.5)) #mfrow is the "matrix" dimension of the par, ex: 8x12 plots, 8 rows, 12 columns
  
  #=================================== For each well ============================================#
  
  for (well in 1:length(sel_wells))
  {
    well_name = sel_wells[well]
    yData = as.numeric(as.vector(red_dataset[[well+1]]))
    
    #Find the well strain **************************************
    well_index = grep_uniq(well_name, as.vector(plt_map[[1]]))
    well_strain = plt_map[[well_index,2]]
    
    #Plot*********************************
    if(well == 2)
    {
      plot(xData,yData, col=AssCol(well_strain), axes=TRUE, frame.plot=TRUE, xlim = time_window, ylim=growth_window,pch = 19,ylab=FALSE,xlab=FALSE)  
    }
    else
    {plot(xData,yData, col=AssCol(well_strain), axes=FALSE, frame.plot=TRUE, xlim = time_window, ylim=growth_window,pch = 19,ylab=FALSE,xlab=FALSE)}
    
    text(time_window[1]+2,growth_window[length(time_window)]-0.1, well_name, cex = 0.6)
  }
}

Ext_384plates <- function(file_path, output_dir, barcode = TRUE)
{
  header <- c("Time", "Barcode",  "PlateID", "Family", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "A10", "A11", "A12", "A13", "A14", "A15", "A16", "A17", "A18", "A19", "A20", "A21", "A22", "A23", "A24", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "B10", "B11", "B12", "B13", "B14", "B15", "B16", "B17", "B18", "B19", "B20", "B21", "B22", "B23", "B24", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "C10", "C11", "C12", "C13", "C14", "C15", "C16", "C17", "C18", "C19", "C20", "C21", "C22", "C23", "C24", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "D10", "D11", "D12", "D13", "D14", "D15", "D16", "D17", "D18", "D19", "D20", "D21", "D22", "D23", "D24", "E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9", "E10", "E11", "E12", "E13", "E14", "E15", "E16", "E17", "E18", "E19", "E20", "E21", "E22", "E23", "E24", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24", "G1", "G2", "G3", "G4", "G5", "G6", "G7", "G8", "G9", "G10", "G11", "G12", "G13", "G14", "G15", "G16", "G17", "G18", "G19", "G20", "G21", "G22", "G23", "G24", "H1", "H2", "H3", "H4", "H5", "H6", "H7", "H8", "H9", "H10", "H11", "H12", "H13", "H14", "H15", "H16", "H17", "H18", "H19", "H20", "H21", "H22", "H23", "H24", "I1", "I2", "I3", "I4", "I5", "I6", "I7", "I8", "I9", "I10", "I11", "I12", "I13", "I14", "I15", "I16", "I17", "I18", "I19", "I20", "I21", "I22", "I23", "I24", "J1", "J2", "J3", "J4", "J5", "J6", "J7", "J8", "J9", "J10", "J11", "J12", "J13", "J14", "J15", "J16", "J17", "J18", "J19", "J20", "J21", "J22", "J23", "J24", "K1", "K2", "K3", "K4", "K5", "K6", "K7", "K8", "K9", "K10", "K11", "K12", "K13", "K14", "K15", "K16", "K17", "K18", "K19", "K20", "K21", "K22", "K23", "K24", "L1", "L2", "L3", "L4", "L5", "L6", "L7", "L8", "L9", "L10", "L11", "L12", "L13", "L14", "L15", "L16", "L17", "L18", "L19", "L20", "L21", "L22", "L23", "L24", "M1", "M2", "M3", "M4", "M5", "M6", "M7", "M8", "M9", "M10", "M11", "M12", "M13", "M14", "M15", "M16", "M17", "M18", "M19", "M20", "M21", "M22", "M23", "M24", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "N10", "N11", "N12", "N13", "N14", "N15", "N16", "N17", "N18", "N19", "N20", "N21", "N22", "N23", "N24", "O1", "O2", "O3", "O4", "O5", "O6", "O7", "O8", "O9", "O10", "O11", "O12", "O13", "O14", "O15", "O16", "O17", "O18", "O19", "O20", "O21", "O22", "O23", "O24", "P1", "P2", "P3", "P4", "P5", "P6", "P7", "P8", "P9", "P10", "P11", "P12", "P13", "P14", "P15", "P16", "P17", "P18", "P19", "P20", "P21", "P22", "P23", "P24")
  dataset <- read.table(file_path, header=FALSE, sep="\t", na.strings="NA", dec=".", strip.white=TRUE, skip = 1, col.names=header)
  
  family_vec <- as.numeric(as.vector(dataset[[4]]))
  nr_families <- max(family_vec)
  
  families_list <- list()
  keep_aux_vec <- vector(mode = "logical", length = length(family_vec))
  for (family in 1:nr_families)
  {
    pos <- grep_exact(family,family_vec)
    
    for (i in 1:length(pos))
    {keep_aux_vec[pos[i]] <- TRUE}
    
    family_data <- subset(dataset,keep_aux_vec)
    families_list[[length(families_list)+1]] <- family_data
    keep_aux_vec = vector(mode = "logical", length = length(family_vec))
  }
  
  #Covert Date and time columns to time-intervals in hours and write the files
  for (family in 1:nr_families)
  {
    family_data = as.data.frame(families_list[family])
    Date_time <- as.character(as.vector(family_data[[1]]))
    
    dtm <- strptime(Date_time, format = "%m/%d/%Y %H:%M:%S", tz = "CET")
    #dtm <- strptime(Date_time, format = "%m/%d/%Y %H:%M", tz = "CET")
    
    Time_h = vector(mode = "numeric", length = length(dtm))  
    for (i in 2:length(Time_h))
    {
      j = i-1
      diff = dtm[i]-dtm[j]
      Time_h[i] = Time_h[j] + as.numeric(diff, units="hours")
    }
    
    Abs = as.matrix(family_data[,5:length(family_data)])
    new_table = cbind(Time_h, Abs)
    PlateID = as.vector(family_data[[3]])
    Barcode = as.vector(family_data[[2]])
    if(barcode == TRUE)
    {out_file = paste0(output_dir,Barcode [1],".txt",collapse=NULL)} else {
      out_file = paste0(output_dir,PlateID [1],".txt",collapse=NULL)
    }
    write.table(new_table,file = out_file, append = FALSE, sep = "\t",row.names = FALSE)
  }
  
}

group_strain <- function(dataset,map_file_path,sel_strain = c()) #Only for full datasets! (not necesseraly full plates)
{
  all_strains_data = list()
  
  if(names(dataset)[1]=="Time_h")
  {sel_wells = names(dataset)[2:length(dataset)]} else
  {sel_wells = names(dataset)[1:length(dataset)]}
  
  #Read the Plate Map  **************************************
  plt_map = read.table(map_file_path, header=TRUE, sep="\t", na.strings="NA", dec=".", strip.white=TRUE)
  
  red_dataset = dataset
  
  #Find the all strains and unique **************************************
  red_dataset_strains = c()
  
  for (well in 1:length(sel_wells))
  {
    well_name = sel_wells[well]
    well_index = grep_uniq(well_name, as.vector(plt_map[[1]]))
    well_strain = plt_map[[well_index,2]]
    red_dataset_strains = c(red_dataset_strains,as.vector(well_strain))
  }
  strains = unique(red_dataset_strains)
  
  #Subselecting sellected strains
  new_strains = c()
  if(length(sel_strain) > 0)
  {
    for(s in 1:length(sel_strain))
    {
      pos = grep_uniq(sel_strain[s],strains)
      new_strains = c(new_strains,strains[pos])
    }
    strains = new_strains
  }
  
  #Group data by Strain
  nr_time_points = length(red_dataset[,1])
  if(length(strains)>0)
  {
    for(i in 1:length(strains))
    {
      strain = strains[i]
      pos = grep_exact(strain, red_dataset_strains)
      
      if(names(dataset)[1]=="Time_h")
      {pos = pos+1}
      
      if(names(dataset)[1]=="Time_h")
      {strain_data = subset(red_dataset, select = c(1,pos))} else
      {strain_data = subset(red_dataset, select = c(pos))}
      
      all_strains_data[[length(all_strains_data)+1]] = strain_data
    }
    names(all_strains_data) = strains
  }
  
  return(all_strains_data)
}

vectorize_dataset <- function(data)
{
  row_names = row.names(data)
  col_names = names(data)
  vec_names = c()
  
  for(c in 1:length(col_names))
  {
    col = col_names[c]
    vec_names = c(vec_names,paste0(row_names,"_",col,collapse=NULL))
  }
  
  vec_data = as.data.frame(as.vector(as.matrix(data)))
  row.names(vec_data)=vec_names
  names(vec_data) = c("Expect fitness") 
  
  return(vec_data)
}
#Screen functions

Cont_check <- function (dataset,map_file_path, wells = c("K7","K9","K11"), cont_tresh = 0.25, plot = FALSE)
{
  contaminated_wells = c()
  
  if (plot == TRUE)
  {Plot_tog(dataset,wells,map_file_path)}
  
  red_data = Red_dataset(dataset,wells)
  
  means = colMeans(red_data[2:length(red_data)],na.rm = TRUE)
  stdev = sapply(red_data[2:length(red_data)],sd,na.rm = TRUE)
  coef_var = stdev/means
  
  for(c in 1:length(wells))
  {
    if(coef_var[c] > cont_tresh)
      contaminated_wells = c(contaminated_wells,(wells[c]))
  }
  
  return(contaminated_wells)
}

SingDon_check <- function (dataset,map_file_path, wells = c("G1","G3","G5"), plot = TRUE)
{
  if (plot == TRUE)
  {Plot_tog(dataset,wells,map_file_path)}  
}

grep_plates <- function(drug,bug,Plate_database,All_Bugs,Updated_D_drugs,Updated_D_codes)
{ 
  if(drug == "Control")
  {drug_code = 0} else
  {drug_code = Updated_D_codes[grep_exact(drug,Updated_D_drugs)]}
  
  if(length(grep(drug,Plate_database$drug))>0)
  {
    drug_plates = Plate_database[grep(drug,Plate_database$drug),]
  } else
  {drug_plates = "drug not found"}
  
  if(drug_plates != "drug not found" && length(grep(bug,drug_plates$bug))>0)
  {
    bug_drug_plates = drug_plates[grep(bug,drug_plates$bug),]
  } else
  {bug_drug_plates="bug not found"}
  
  if(drug_plates != "drug not found" && bug_drug_plates !="bug not found")
  {return(as.character(bug_drug_plates[[1]]))} else
  {return("Bug or drug not found")}
  
  
}

getPlate_id <- function(full_drug_name,D_codes,Drugs,All_Bugs)
{
  #repl = substr(full_drug_name,nchar(full_drug_name),nchar(full_drug_name))
  repl = strsplit(full_drug_name,split=" rep ")[[1]][[2]]
  conc_pre = strsplit(full_drug_name,split=" rep ")[[1]][[1]]
  
  conc = substr(conc_pre,nchar(conc_pre),nchar(conc_pre))
  
  if(conc != 0)
  {
    drug = strsplit(full_drug_name,split=" rep ")[[1]][[1]]
    drug = substr(drug,1,nchar(drug)-2)
    
    #drug_code = D_codes[grep_exact(drug,Drugs)]#changed to the one bellow
    drug_code = D_codes[grep(drug,Drugs)]
    if(drug_code<10) {drug_code=paste0("0",drug_code,collapse = NULL)}
  
  } else {drug_code = "00"}
  
  bug_code = Bug_codes[grep_exact(bug,All_Bugs)]
  Plate_id = paste0("P",bug_code,drug_code,conc,repl,collapse=NULL)
  return(Plate_id)
}

getPlate_ids <- function(full_drug_names,D_codes,Drugs,All_Bugs)
{
  Plate_ids = c()
  for(i in 1:length(full_drug_names))
  {
    
    full_drug_name = full_drug_names[i]
    Plate_id = getPlate_id(full_drug_name,D_codes,Drugs,All_Bugs)
        
    Plate_ids = c(Plate_ids,Plate_id)
  }
  
  return(Plate_ids)
}

get_short_donor <- function(donor, conc=FALSE)
{
  if(conc==FALSE)
  {
    short_donor = strsplit(donor," ")[[1]][1:(length(strsplit(donor," ")[[1]])-3)]
    if(length(short_donor)>1)
    {short_donor = paste0(short_donor[1]," ",short_donor[2],collapse = NULL)}
  } else
  {
    donor_conc_vec = strsplit(donor," ")[[1]][1:(length(strsplit(donor," ")[[1]])-2)]
    i=1
    donor_conc = ""
    while(i <= length(donor_conc_vec))
    {
      donor_conc = paste0(donor_conc,donor_conc_vec[i]," ",collapse = NULL)
      i = i+1
    }
    donor_conc = substr(donor_conc,1,(nchar(donor_conc)-1))
    
    short_donor=donor_conc
  }
  
  return(short_donor)
}

get_feature <- function(plate_ids,feature,Plate_database) #Feb 2015
{
  All_features = names(Plate_database)
  features = c()
  if(length(grep_exact(feature,All_features))>0)
  {
    column = grep_exact(feature,All_features)
    for(p in 1:length(plate_ids))
    {
      plate_id = plate_ids[p]
      features = c(features,as.character(Plate_database[grep_exact(plate_id,Plate_database[[1]]),column]))
    }
  }
  
  return(features)
}

#gets a vec of combinations and returns a vec with the classes per combination
get_class_comb <- function(combs,Attr_table)
{
  Class_comb = c(paste0(as.character(as.matrix(as.data.frame(combn(unique(as.character(Attr_table[[2]])),2))[1,])),"_",
                        as.character(as.matrix(as.data.frame(combn(unique(as.character(Attr_table[[2]])),2))[2,]))),
                 paste0(unique(as.character(Attr_table[[2]])),"_",unique(as.character(Attr_table[[2]])))) #self class combinations
  
  combs_drug1 = unlist(strsplit(combs,split="_"))[seq(1,length(unlist(strsplit(combs,split="_"))),by=2)]
  combs_drug2 = unlist(strsplit(combs,split="_"))[seq(2,length(unlist(strsplit(combs,split="_"))),by=2)]
  combs_class1 = as.character(Attr_table[unlist(sapply(combs_drug1,FUN=grep,x=as.character(Attr_table[[1]]))),2])
  combs_class2 = as.character(Attr_table[unlist(sapply(combs_drug2,FUN=grep,x=as.character(Attr_table[[1]]))),2])
  
  combs_class = paste0(combs_class1,"_",combs_class2)
  combs_class_rev = paste0(combs_class2,"_",combs_class1)
  combs_class_final = combs_class
  combs_class_final[grep(T,combs_class_rev %in% Class_comb)] = combs_class_rev[grep(T,combs_class_rev %in% Class_comb)]
  
  return(combs_class_final)
}

get_Masterclass_comb <- function(combs,Attr_table) #added on 24-08-2016
{
  Class_comb = c(paste0(as.character(as.matrix(as.data.frame(combn(unique(as.character(Attr_table[[3]])),2))[1,])),"_",
                        as.character(as.matrix(as.data.frame(combn(unique(as.character(Attr_table[[3]])),2))[2,]))),
                 paste0(unique(as.character(Attr_table[[2]])),"_",unique(as.character(Attr_table[[3]])))) #self class combinations
  
  combs_drug1 = unlist(strsplit(combs,split="_"))[seq(1,length(unlist(strsplit(combs,split="_"))),by=2)]
  combs_drug2 = unlist(strsplit(combs,split="_"))[seq(2,length(unlist(strsplit(combs,split="_"))),by=2)]
  combs_class1 = as.character(Attr_table[unlist(sapply(combs_drug1,FUN=grep,x=as.character(Attr_table[[1]]))),3])
  combs_class2 = as.character(Attr_table[unlist(sapply(combs_drug2,FUN=grep,x=as.character(Attr_table[[1]]))),3])
  
  combs_class = paste0(combs_class1,"_",combs_class2)
  combs_class_rev = paste0(combs_class2,"_",combs_class1)
  combs_class_final = combs_class
  combs_class_final[grep(T,combs_class_rev %in% Class_comb)] = combs_class_rev[grep(T,combs_class_rev %in% Class_comb)]
  
  return(combs_class_final)
}

#color_by <- function(plate_ids,feature_col,Plate_database,colors = c("#236467","#AA3C39","#AA8539")) #Sept 2015
color_by <- function(plate_ids,feature_col,Plate_database,colors = c("#5D2B96","#DE9D33","#30B429")) #Jan 2016
{
  runs = get_feature(plate_ids,feature = feature_col,Plate_database)
  base_cols = colorRampPalette(colors)(length(unique(runs)))
  cols = rep("white",length(runs))
  for(r in 1:length(unique(runs)))
  {
    cols[grep_exact(unique(runs)[r],runs)] = base_cols[r]
  }
  
  out_cols = list(cols,base_cols,unique(runs))
  names(out_cols) = c("colors","legend_colors","legend_runs")
  
  return(out_cols)
}

norm_byRun <- function(data,feature_norm="run",Plate_database=Plate_database) #Sept 2015
{
  norm_data = data
  runs = get_feature(names(data),feature=feature_norm,Plate_database)
  for(r in 1:length(unique(runs)))
  {
    data_run = data[grep_exact(unique(runs)[r],runs)]
    third_quantile_run = quantile(sapply(data_run,FUN=median,na.rm=T))[4]
    norm_data[grep_exact(unique(runs)[r],runs)] = (norm_data[grep_exact(unique(runs)[r],runs)])/third_quantile_run
  }
  
  return(norm_data)
}

norm_byPlate <- function(data,quant = 0.99,plotting=T,color_ref="run") #Sept 2015
{
  
  color_set = color_by(names(data),color_ref,Plate_database)
  if(plotting==T)
  {
    par(mfrow=c(2,1),mar=c(6,3,2,3))
    boxplot(data,cex=0.5,pch=19,las=2,col=color_set$colors,main="Raw data",cex.axis=0.7,na.action=na.exclude)
    legend("topleft",legend = color_set$legend_runs,pch=19,col=color_set$legend_colors,bty="n",cex=0.5,
           y.intersp = 0.2,x.intersp=0.5,horiz = T, text.width = 4)
  }
  
  norm_data = data
  for(p in 1:length(data))
  {
    norm_data[p] = norm_data[p]/(median(data[grep(T,data[[p]]>quantile(data[[p]],probs = quant,na.rm=T)),p]))
    
    if(plotting==T)
    {
      points(rep(p,round((384*(1-quant)),0)),data[grep(T,data[[p]]>quantile(data[[p]],probs = quant,na.rm=T)),p],col=color_set$colors[p],
             pch=19,cex=0.8)
    }
  }
  
  if(plotting==T)
  {
    boxplot(norm_data,cex=0.5,pch=19,las=2,col=color_set$colors,cex.axis=0.7,na.action=na.exclude,
            main=paste0("Normalized by plate, top ",round((384*(1-quant)),0), " wells"))
    legend("topleft",legend = color_set$legend_runs,pch=19,col=color_set$legend_colors,bty="n",cex=0.5,
           y.intersp = 0.2,x.intersp=0.5,horiz = T, text.width = 4)
  }
  
  return(norm_data)
}

detect_high_baseline <- function(plate_ids,Load_dir_raw,outlier_threshold = 1.3,plotting=T) #Sept 2015
{
  for(p in 1:length(plate_ids))
  {
    plate_id = plate_ids[p]
    file_id = paste0(Load_dir_raw,plate_id,".txt")
    dataset = read.table(file_id, header=TRUE, sep="\t", na.strings="NA", dec=".", strip.white=TRUE)
    
    time_point_data = as.data.frame(t(dataset[3,2:length(dataset)]))
    names(time_point_data) = plate_id
    if(p==1)
    {baseline = time_point_data} else
    {baseline = as.data.frame(cbind(baseline,time_point_data))}
  }
  
  if(plotting==T)
  {
    par(mfrow=c(3,1))
    boxplot(as.data.frame(t(baseline)),pch=19,cex=0.5,las=2,cex.axis=0.5,border = "grey",main="Baseline per well")
  }
  
  medianwells = sapply(as.data.frame(t(baseline)),FUN = median)
  for(p in 1:length(baseline))
  {
    p_data = baseline[[p]]
    
    x_data = grep(T,p_data>(medianwells*outlier_threshold))
    y_data = baseline[x_data,p]
    if(plotting==T)
    {points(x_data,y_data,pch=19,cex=0.5,col="red3")}
    
    wells = row.names(baseline)[x_data]
    if(p==1)
    {Wells_to_remove = list()}
    Wells_to_remove[[length(Wells_to_remove)+1]] = wells
    
    
  }
  names(Wells_to_remove) = names(baseline)
  
  if(plotting==T)
  {
    percent_wells = round(length(unlist(Wells_to_remove))/length(as.vector(as.matrix(baseline)))*100,2)
    barplot(sort(table(unlist(Wells_to_remove))),col="white",las=2,cex.names=0.5,main="Nr instances per well")
    barplot(sort(unlist(lapply(Wells_to_remove,FUN=length))),col="white",las=2,cex.names=0.7,main="Nr wells per plate")
    title(paste0("High baseline wells - total = ",percent_wells,"%"),outer=T,line=-1)
  }
  
  return(Wells_to_remove)
  
  
}

detect_high_endpoint <- function(plate_ids,Load_dir_raw,Plate_database=Plate_database,outlier_threshold = 1.3,plotting=T) #Sept 2015
{
  for(p in 1:length(plate_ids))
  {
    plate_id = plate_ids[p]
    file_id = paste0(Load_dir_raw,plate_id,".txt")
    dataset = read.table(file_id, header=TRUE, sep="\t", na.strings="NA", dec=".", strip.white=TRUE)
    
    if(length(dataset[[1]])>=17)
    {time_point=17} else
    {time_point=length(dataset[[1]])}
    
    time_point_data = as.data.frame(t(dataset[time_point,2:length(dataset)]))
    names(time_point_data) = plate_id
    if(p==1)
    {baseline = time_point_data} else
    {baseline = as.data.frame(cbind(baseline,time_point_data))}
  }
  
  norm_baseline = norm_byRun(baseline,Plate_database=Plate_database)
  
  if(plotting==T)
  {
    par(mfrow=c(3,1))
    boxplot(as.data.frame((norm_baseline)),pch=19,cex=0.5,las=2,cex.axis=0.5,border = "grey",
            main="Late time point per plate - normalised by run")
    points(c(-100,200),c(outlier_threshold,outlier_threshold),type="l")
  }
  
  for(p in 1:length(norm_baseline))
  {
    p_data = norm_baseline[[p]]
    
    x_data = grep(T,p_data>outlier_threshold)
    y_data = norm_baseline[x_data,p]
    wells = row.names(norm_baseline)[x_data]
    x_data = rep(p,length(x_data))
    if(plotting==T)
    {points(x_data,y_data,pch=19,cex=0.5,col="red3")}
    
    if(p==1)
    {Wells_to_remove = list()}
    Wells_to_remove[[length(Wells_to_remove)+1]] = wells
    
    
  }
  names(Wells_to_remove) = names(baseline)
  
  if(plotting==T)
  {
    percent_wells = round(length(unlist(Wells_to_remove))/length(as.vector(as.matrix(baseline)))*100,2)
    barplot(sort(table(unlist(Wells_to_remove))),col="white",las=2,cex.names=0.7,main="Nr instances per well")
    barplot(sort(unlist(lapply(Wells_to_remove,FUN=length))),col="white",las=2,cex.names=0.7,main="Nr wells per plate")
    title(paste0("High late-point wells - total = ",percent_wells,"%"),outer=T,line=-1)
  }
  
  return(Wells_to_remove)  
}

get_baseline<-function(plate_ids,Load_dir,time_point,list_plates=list()) #Sept 2015
{
  
  for(p in 1:length(plate_ids))
  {
    plate_id = plate_ids[p]
    
    if(length(list_plates)==0)
    {
      file_id = paste0(Load_dir,plate_id,".txt")
      dataset = read.table(file_id, header=TRUE, sep="\t", na.strings="NA", dec=".", strip.white=TRUE)
    } else
    {dataset = list_plates[[grep_exact(plate_id,names(list_plates))]]}
    
    time_point_data = as.data.frame(t(dataset[time_point,2:length(dataset)]))
    names(time_point_data) = plate_id
    if(p==1)
    {baseline = time_point_data} else
    {baseline = as.data.frame(cbind(baseline,time_point_data))}
  }
  
  return(baseline)
}

wells_median_correl<-function(data1,data2,x_lab="",y_lab="",plot_title="",feature_col="conc",Map=Map,plot_lims=c(0.2,0.8))  #Sept 2015
{
  colorset = color_by(row.names(data1),feature_col=feature_col,Map)
  plot(sapply(as.data.frame(t(data1)),FUN=median),
       sapply(as.data.frame(t(data2)),FUN=median),
       pch=19,col=colorset$colors,ylim=plot_lims,xlim=plot_lims, xlab=x_lab,ylab=y_lab,
       main = plot_title,cex.main=0.7)
  legend("topright",legend = colorset$legend_runs,pch=19,col=colorset$legend_colors,bty="n",cex=0.7)
  fit = lm(sapply(as.data.frame(t(data2)),FUN=median)~sapply(as.data.frame(t(data1)),FUN=median))
  abline(fit)
  R = cor(sapply(as.data.frame(t(data1)),FUN=median),
          sapply(as.data.frame(t(data2)),FUN=median))
  slope = round(fit$coefficients[[2]],2)
  intercept = round(fit$coefficients[[1]],2)
  text(x=(plot_lims[1]+0.05),y=(plot_lims[2]-0.05),adj=0,labels=paste0("R=",round(R,2)))
  text(x=(plot_lims[1]+0.05),y=(plot_lims[2]-0.1),adj=0,labels=paste0("slope=",slope))
  text(x=(plot_lims[1]+0.05),y=(plot_lims[2]-0.15),adj=0,labels=paste0("intercept=",intercept))
  
}

get_baseline_coefficients<-function(subset_data,plot_fits=F,plot_baselines=F,plot_lims=c(0.2,0.8),title="") #Sept 2015
{
  for(l in 1:length(LETTERS[seq(1,16)]))
  {
    letter = LETTERS[seq(1,16)][l]
    row_data = subset_data[grep(letter,row.names(subset_data)),]
    #xData = seq(1,length(row_data[[1]]))
    xData=as.numeric(substr(row.names(row_data),2,nchar(row.names(row_data))))
    
    for(p in 1:length(row_data))
    {
      fit=lm(row_data[[p]]~xData)
      slope = fit$coefficients[[2]]
      intercept = fit$coefficients[[1]]
      r = round(cor(fit$fitted.values,row_data[[p]]),2)
      
      plate_data = as.data.frame(c(slope,intercept,r))
      row.names(plate_data) = c("slope","intercept","r")
      names(plate_data) = paste0(letter,"_",names(row_data)[p])
      
      if(l==1 && p==1)
      {Fit_baseline = plate_data} else
      {Fit_baseline = as.data.frame(cbind(Fit_baseline,plate_data))}
    }
  }
  
  Fit_baseline = as.data.frame(t(Fit_baseline))
  Matslopes = as.data.frame(matrix(Fit_baseline[[1]],nrow=length(row_data)))
  names(Matslopes) = LETTERS[seq(1,16)]
  row.names(Matslopes) = names(row_data)
  median_slopes = sapply(Matslopes,FUN=median)
  Matslopes = as.data.frame(matrix(Fit_baseline[[2]],nrow=length(row_data)))
  names(Matslopes) = LETTERS[seq(1,16)]
  row.names(Matslopes) = names(row_data)
  median_intercepts = sapply(Matslopes,FUN=median)
  
  Fit_baseline = as.data.frame(cbind(median_slopes,median_intercepts))
  row.names(Fit_baseline) = names(median_slopes)
  names(Fit_baseline) = c("Slope","Intercept")
  
  if(plot_baselines==T)
  {
    par(mfrow=c(4,4),mar=c(2.5,2.5,2.5,2.5))
    for(l in 1:length(LETTERS[seq(1,16)]))
    {
      letter = LETTERS[seq(1,16)][l]
      row_data = subset_data[grep(letter,row.names(subset_data)),]
      xData = seq(1,length(row_data[[1]]))
      plot(xData,row_data[[1]],cex=0.5,pch=19,type="l",ylab="OD",xlab="column",ylim=plot_lims,col=rgb(0.5,0.5,0.5,alpha = 0.5),frame=T,axes=F,
           main=letter)
      for(p in 2:length(row_data))
      {
        points(xData,row_data[[p]],cex=0.5,pch=19,type="l",col=rgb(0.5,0.5,0.5,alpha = 0.5))
      }
      abline(Fit_baseline[l,2],Fit_baseline[l,1],col="red3",lwd=2)
       
    }
    title(title,outer=T,line=-1)
  }
  
  if(plot_fits==T)
  {
    cols = colorRampPalette(c("#D44C2C","#1F945C"))(16)
    ltys = sample(x=seq(1,6),size=16,repla=T)
    
    if(plot_baselines==T)
    {par(mfrow=c(1,1),mar=c(6,6,6,6))}
    for(l in 1:length(LETTERS[seq(1,16)]))
    {
      letter = LETTERS[seq(1,16)][l]
      row_data = subset_data[grep(letter,row.names(subset_data)),]
      xData=as.numeric(substr(row.names(row_data),2,nchar(row.names(row_data))))
      if(l==1)
      {plot(xData,row_data[[1]],cex=0.8,pch=19,type="n",ylab="OD",xlab="column",ylim=plot_lims,col=rgb(0.5,0.5,0.5,alpha = 0.5),
            main=title)}
      
      abline(Fit_baseline[l,2],Fit_baseline[l,1],col=cols[l],lty=ltys[l],lwd=2)
      
    }
    legend("topleft",legend=LETTERS[seq(1,16)][1:8],col=cols[1:8],bty="n",cex=0.7,lty=ltys[1:8],lwd=2)
    legend("topright",legend=LETTERS[seq(1,16)][9:16],col=cols[9:16],bty="n",cex=0.7,lty=ltys[9:16],lwd=2)
  }
  
  return(Fit_baseline)
}

fit_baseline <- function(subset_data,plot_lims=c(0.2,0.8)) #Sept 2015
{
  slopes = c()
  intercepts = c()
  for(l in 1:length(LETTERS[seq(1,16)]))
  {
    letter = LETTERS[seq(1,16)][l]
    row_data = subset_data[grep(letter,row.names(subset_data)),]
    concs = get_feature(row.names(row_data),feature="conc",Plate_database=Map)
    if(length(grep(1,concs))>0)
    {
      row_data = row_data[-grep(1,concs),]
      concs = get_feature(row.names(row_data),feature="conc",Plate_database=Map) 
    }
    drugs = get_feature(row.names(row_data),feature="drug",Plate_database=Map)
    if(length(grep("Control",drugs))>0)
    {
      row_data = row_data[-grep("Control",drugs),]
      concs = get_feature(row.names(row_data),feature="conc",Plate_database=Map)
    }
    
    xData=as.numeric(substr(row.names(row_data),2,nchar(row.names(row_data))))
    cols=color_by(row.names(row_data),feature_col = "conc",Plate_database=Map)
    #boxplot(t(row_data),las=2,col=cols$colors,main=letter)
    row_median = sapply(as.data.frame(t(row_data)),FUN=median)
    plot(xData,row_median,col=cols$colors,pch=19,type="b",ylim=plot_lims,main=letter,xlab="column",ylab="Well median across plates")
    text(xData,row_median+0.03,labels=row.names(row_data),cex=0.7)
    fit = lm(row_median~xData)
    abline(fit)
    r = round(cor(xData,row_median),2)
    text(x=plot_lims[1]+3,y=plot_lims[2]-0.05,adj=0,labels=paste0("R=",r))
    text(x=plot_lims[1]+3,y=plot_lims[2]-0.03,adj=0,labels=paste0("slope=",round(fit$coefficients[[2]],4)))
    slopes = c(slopes,fit$coefficients[[2]])
    intercepts = c(intercepts,fit$coefficients[[1]])
  }
  slopes=as.data.frame(slopes)
  row.names(slopes)=LETTERS[seq(1,16)]
  intercepts = as.data.frame(intercepts)
  row.names(intercepts) = LETTERS[seq(1,16)]
  
  return(as.data.frame(cbind(slopes,intercepts)))
}

fitness_calc <- function(batch_QC3_data,batch_high_q_data,drugs_to_clean_up,Plate_database=Plate_database,Map=Map,plotting=F) #Sept 2015
{
  control_wells = row.names(batch_QC3_data)[grep("LB",get_feature(row.names(batch_QC3_data),feature = "drug",Plate_database=Map))]
  
  low_growth_wells = c()
  for(d in 1:length(drugs_to_clean_up))
  {
    drug = drugs_to_clean_up[d]
    low_growth_wells = c(low_growth_wells,as.character(Map[grep_exact(drug,as.character(Map$drug)),1]))
  }
  high_wells = grep(1,as.numeric(get_feature(row.names(batch_QC3_data),feature = "conc",Plate_database=Map)))
  high_wells = c(high_wells,grep("LB",get_feature(row.names(batch_QC3_data),feature = "drug",Plate_database=Map)))
  high_wells = sort(unique(c(high_wells,match(low_growth_wells,row.names(batch_QC3_data)))))
  
  high_fit=match(row.names(batch_high_q_data),row.names(batch_QC3_data))
  
  #Normalize to Control wells or median of high fit wells
  norm_factor = sapply(batch_QC3_data[match(control_wells,row.names(batch_QC3_data)),],FUN=median,na.rm=T)
  norm_factor[sapply(batch_QC3_data[high_fit,],FUN=median,na.rm=T)>sapply(batch_QC3_data[match(control_wells,row.names(batch_QC3_data)),],FUN=median,na.rm=T)]=
    sapply(batch_QC3_data[high_fit,],FUN=median,na.rm=T)[sapply(batch_QC3_data[high_fit,],FUN=median,na.rm=T)>sapply(batch_QC3_data[match(control_wells,row.names(batch_QC3_data)),],FUN=median,na.rm=T)]
  
  norm_batch_QC3_data = as.data.frame(t(as.data.frame(t(batch_QC3_data))/norm_factor))
  
  test=as.matrix(norm_batch_QC3_data)
  #length(test[test>1.1])/length(test)*100
  #length(test[test<0])/length(test)*100
  test[test>1]=1
  test[test<0]=0
  test=as.data.frame(test)
  norm_batch_QC3_data=test
  
  if(plotting==T)
  {
    colorset = color_by(names(batch_QC3_data),feature_col = "conc",Plate_database)
    boxplot(norm_batch_QC3_data[1:50],pch=19,cex=0.5,col=colorset$colors[1:50],ylim=c(0,1.1),main="Normlized to Controls",las=2,cex.axis=0.7)
    points(seq(1,length(norm_batch_QC3_data[1:50])),sapply(norm_batch_QC3_data[match(control_wells,row.names(batch_QC3_data)),1:50],FUN=median,na.rm=T),type="b",pch=10,col="blue")
    points(seq(1,length(norm_batch_QC3_data[1:50])),sapply(norm_batch_QC3_data[(high_fit),1:50],FUN=median,na.rm=T),type="b",pch=10,col="green")
    points(seq(1,length(norm_batch_QC3_data[1:50])),sapply(norm_batch_QC3_data[(-high_wells),1:50],FUN=median,na.rm=T),type="b",pch=10,col="red3")
    points(c(-1,200),c(0.9,0.9),type="l")
    points(c(-1,200),c(0.8,0.8),type="l")
  }
  
  #f1_estimate = as.data.frame(sapply(norm_batch_QC3_data[-high_wells,],FUN=median,na.rm=T))
  f1_estimate = as.data.frame(sapply(norm_batch_QC3_data[high_fit,],FUN=median,na.rm=T))
  names(f1_estimate) = c("f1_estimate")
  
  to_return = list(norm_batch_QC3_data,f1_estimate)
  names(to_return) = c("norm_data","f1_estimate")
  return(to_return)
}

fitness_calc_EC_bt1 <- function(batch_QC3_data,batch_high_q_data,drugs_to_clean_up,Plate_database=Plate_database,Map=Map,plotting=F) #Sept 2015
{
  high_fit=match(row.names(batch_high_q_data),row.names(batch_QC3_data))
  
  #Normalize to  or median of high fit wells
  norm_factor = sapply(batch_high_q_data,FUN=quantile,probs=c(0.50),na.rm=T)
  quantile_995 = sapply(batch_QC3_data,FUN=quantile,probs=c(0.995),na.rm=T)
  norm_factor[norm_factor<0.23]=quantile_995[norm_factor<0.23]
  
  norm_batch_QC3_data = as.data.frame(t(as.data.frame(t(batch_QC3_data))/norm_factor))
  
  test=as.matrix(norm_batch_QC3_data)
  #length(test[test>1.1])/length(test)*100
  #length(test[test<0])/length(test)*100
  test[test>1]=1
  test[test<0]=0
  test=as.data.frame(test)
  norm_batch_QC3_data=test
  
  if(plotting==T)
  {
    colorset=color_by(names(batch_QC3_data),feature_col="conc",Plate_database)
    
    plot(sapply(batch_QC3_data,FUN=quantile,probs=c(0.995),na.rm=T),
         sapply(batch_high_q_data,FUN=quantile,probs=c(0.50),na.rm=T),col=colorset$colors,pch=19,main=bug)
    points(c(-1,1),c(-1,1),type="l")
        
    boxplot(batch_QC3_data[1:40],las=2,cex.axis=0.7,cex=0.5,pch=19,border=colorset$colors,main=bug)
    boxplot(batch_high_q_data[1:40],las=2,cex.axis=0.7,cex=0.5,pch=19,col=colorset$colors,add=T)
  }
  
  #f1_estimate = as.data.frame(sapply(norm_batch_QC3_data[-high_wells,],FUN=median,na.rm=T))
  f1_estimate = as.data.frame(sapply(norm_batch_QC3_data[high_fit,],FUN=median,na.rm=T))
  names(f1_estimate) = c("f1_estimate")
  
  to_return = list(norm_batch_QC3_data,f1_estimate)
  names(to_return) = c("norm_data","f1_estimate")
  return(to_return)
}

sinfit_profiler <- function(data,Plate_database) #Sept 2015
{
  drugs = as.character(get_feature(row.names(data),feature = "drug",Plate_database))
  
  par(mfrow=c(6,6),mar=c(1,1,1,1))
  for(d in 1:length(unique(drugs)))
  {
    drug = unique(drugs)[d]
    drug_plates = row.names(data)[grep_exact(drug,drugs)]
    drug_runs = as.character(get_feature(drug_plates,feature = "run",Plate_database))
    
    for(r in 1:length(unique(drug_runs)))
    {
      plates_plot = drug_plates[grep_exact(unique(drug_runs)[r],drug_runs)]
      conc_plot = as.numeric(get_feature(plates_plot,feature = "conc",Plate_database))
      g1_plot = data[match(plates_plot,row.names(data)),]
      
      color="black"
      if(length(g1_plot)>=2)
      {
        if(g1_plot[1]>g1_plot[2]*1.1)
        {color="orange"}
        if(g1_plot[1]>g1_plot[length(g1_plot)]*1.1)
        {color="red3"}
      }
      
      plot(conc_plot,g1_plot,pch=19,cex=0.6,type="b",ylab="Drug concentration",xlab="Drug fitness",xlim=c(0,4),ylim=c(0,1.5),frame=T,axes=F,col=color)
      points(c(-1,6),c(1,1),col="grey",type="l")
      text(x=1,y=1.2,labels=drug,adj=0)
    }
    
  }
  
}

Plot_screen <- function(dataset,map_file_path2,growth_window = c(-0.1,0.6),time_window = c(0,14),correction = TRUE)
{
  sel_wells = names(dataset)[1:length(dataset)]
  
  if(correction==TRUE)
  {dataset = Corr_baseline(dataset)}
  
  grouped_data = group_strain(dataset,map_file_path2)
  Drugs_single = c(Drugs,"SingleDrug")
  
  par(mfrow=c(8,8), mar = c(0.5,1,2,1))
  for(d in 1:length(Drugs_single))
  {
    r_drug = Drugs_single[d]
    data_pos = grep(r_drug,names(grouped_data),fixed=TRUE)
    
    # Add plots of controls in the single
    if(r_drug == "SingleDrug")
    {
      pos2 = grep("LB",names(grouped_data),fixed=TRUE)
      data_pos = c(data_pos,pos2)
    }
    
    if(length(data_pos)>0)
    {
      if(r_drug == "SingleDrug")
      {colors = c("black","dodgerblue")} else
      {colors = c("red2","darkgoldenrod1","chartreuse3")}
      
      for(i in 1:length(data_pos))
      {
        plot_data = as.data.frame(grouped_data[[data_pos[i]]])
        xData = as.numeric(as.vector(plot_data[[1]]))
                
        for(j in 2:length(plot_data))
        {
          yData = as.numeric(as.vector(plot_data[[j]]))
                    
          if(i == 1 && j == 2)
          {
            plot(xData,yData, col = colors[i], xlim=time_window,ylim = growth_window, ylab = "", xlab = "", frame = TRUE,axes = FALSE, type = "l")
            points(c(9,9),c(growth_window[1],growth_window[2]),type = "l")
          } else
          {points(xData,yData, col = colors[i], type = "l")}
        }        
      }
      title(r_drug, cex = 0.5, line = 0.5)
      if(r_drug == "SingleDrug")
      {legend(x = 10, y = growth_window[1]+0.3, legend = c("No drug","Single drug"), fill = c("dodgerblue","black"),cex = 0.5)}
    }
  }  
}

Smooth_reads_old <- function(dataset, thresh = 0.1, thresh2 = -0.02, cutoff_wells = 10, plot = FALSE, outputfile = "") #Removing "bad reads" - smoothing function
{
  #Work on the 1st quadrant. Enough, simple and possible to plot.
  data <- quadr(1,dataset)
  sel_wells = names(data[2:length(data)])
  
  sel_data = Red_dataset(data,sel_wells)
  time_points = c()
  
  #Find out the values that have abnormal "progression"
  if(plot == TRUE)
  {par(mfrow = c(8,12), mar = c(1,1,1,1))}
  for(i in 1:length(sel_wells))
  {
    sel_well = sel_wells[i]
    red_data = Red_dataset(sel_data,sel_well)
    
    if(plot == TRUE)
    {plot(red_data, ylim = c(-0.1,0.6))}
    
    vec = as.numeric(as.vector(red_data[[2]]))
    vec2 = c(0,vec)
    vec = c(vec,0)
    vecMinus = (vec2-vec)*(-1)
    
    new_vecMinus = vecMinus[1:(length(vecMinus)-1)]
    time = as.numeric(as.vector(red_data[[1]]))
    if(plot == TRUE)
    {
      points(time,new_vecMinus, col = "green")
      lines(time,new_vecMinus, col = "green")
    }#if(plot == TRUE)
    
    flag1 = new_vecMinus > thresh
    pos = grep("TRUE",flag1)
    if(length(pos)>0)
    {
      for(j in 1:length(pos))
      {
        if(pos[j]!= 1)
        {
          time_point = pos[j]
          if(time_point != length(new_vecMinus) && new_vecMinus[pos[j]+1]<thresh2)
          {
            time_points = c(time_points,time_point)
            if(plot == TRUE)
            {
              marked = red_data[time_point,]
              points(marked, col = "green",pch = 19)
            }
          } #if(new_vecMinus[pos[j]+1]<thresh2)
        }#if(pos[j]!= 1)
      }#for(j in 1:length(pos))
    }#if(length(pos)>0)
  } #for(i in 1:length(sel_wells))
  
  smooth_data = dataset
  if(length(time_points)>0)
  {
    #Count how many instanced per point withihn the 1st quadrant
    uni = unique(time_points)
    counts = c()
    for(i in 1:length(uni))
    {
      time_point = uni[i]
      pos = grep_exact(time_point,time_points)
      counts = c(counts,length(pos))
    }
    
    #Select time points to be removed from dataset based on the cutoff
    time_points = c()
    for(i in 1:length(uni))
    {
      time_point = uni[i]
      count = counts[i]
      
      if(count >= cutoff_wells)
      {time_points = c(time_points,dataset[time_point,1])}
    }
    
    #Reduce the dataset by removing the desired points
    if(length(time_points)>0)
    {
      for(i in 1:length(time_points))
      {
        time_point = time_points[i]
        smooth_data = subset.data.frame(smooth_data,subset = (Time_h != time_point), select = seq(1,length(dataset)))
      }
    }
    
    if(plot == TRUE)
    {
      par(mfrow = c(8,12), mar = c(1,1,1,1))
      for(i in 1:length(sel_wells))
      {
        sel_well = sel_wells[i]
        red_data = Red_dataset(smooth_data,sel_well)
        
        plot(red_data, ylim = c(-0.1,0.6), col = "pink", pch = 19)
      }
    }
  } #if(length(time_points)>0)
  
  if(outputfile != "")
  {write.table(smooth_data, file = outputfile,quote = FALSE, row.names = FALSE, sep = "\t")}
  
  return(smooth_data)
}

#Copied from Prestwick_functions on the 18/02/2015
Smooth_reads <- function(dataset, thresh = 0.1, thresh2 = -0.02, cutoff_wells = 10, plot = FALSE, outputfile = "") #Removing "bad reads" - smoothing function
{
  #Work on the 1st quadrant. Enough, simple and possible to plot.
  data <- quadr(1,dataset)
  sel_wells = names(data[2:length(data)])
  
  sel_data = Red_dataset(data,sel_wells)
  time_points = c()
  
  #Find out the values that have abnormal "progression"
  if(plot == TRUE)
  {par(mfrow = c(8,12), mar = c(1,1,1,1))}
  for(i in 1:length(sel_wells))
  {
    sel_well = sel_wells[i]
    red_data = Red_dataset(sel_data,sel_well)
    
    if(plot == TRUE)
    {plot(red_data, ylim = c(-0.1,0.6))}
    
    vec = as.numeric(as.vector(red_data[[2]]))
    vec2 = c(0,vec)
    vec = c(vec,0)
    vecMinus = (vec2-vec)*(-1)
    
    new_vecMinus = vecMinus[1:(length(vecMinus)-1)]
    time = as.numeric(as.vector(red_data[[1]]))
    if(plot == TRUE)
    {
      points(time,new_vecMinus, col = "green")
      lines(time,new_vecMinus, col = "green")
    }#if(plot == TRUE)
    
    flag1 = new_vecMinus > thresh
    pos = grep("TRUE",flag1)
    if(length(pos)>0)
    {
      for(j in 1:length(pos))
      {
        if(pos[j]!= 1)
        {
          time_point = pos[j]
          if(time_point != length(new_vecMinus) && new_vecMinus[pos[j]+1]<thresh2)
          {
            time_points = c(time_points,time_point)
            if(plot == TRUE)
            {
              marked = red_data[time_point,]
              points(marked, col = "green",pch = 19)
            }
          } #if(new_vecMinus[pos[j]+1]<thresh2)
        }#if(pos[j]!= 1)
      }#for(j in 1:length(pos))
    }#if(length(pos)>0)
  } #for(i in 1:length(sel_wells))
  
  smooth_data = dataset
  if(length(time_points)>0)
  {
    #Count how many instances per point withihn the 1st quadrant
    uni = unique(time_points)
    counts = c()
    for(i in 1:length(uni))
    {
      time_point = uni[i]
      pos = grep_exact(time_point,time_points)
      counts = c(counts,length(pos))
    }
    
    #Select time points to be removed from dataset based on the cutoff
    time_points = c()
    for(i in 1:length(uni))
    {
      time_point = uni[i]
      count = counts[i]
      
      if(count >= cutoff_wells)
      {time_points = c(time_points,dataset[time_point,1])}
    }
    
    #Reduce the dataset by removing the desired points
    if(length(time_points)>0)
    {
      for(i in 1:length(time_points))
      {
        time_point = time_points[i]
        smooth_data[grep(time_point,smooth_data[[1]]),2:length(smooth_data)] = 
          colMeans(rbind(smooth_data[(grep(time_point,smooth_data[[1]]))+1,2:length(smooth_data)],smooth_data[(grep(time_point,smooth_data[[1]]))-1,2:length(smooth_data)]))
        #smooth_data = subset.data.frame(smooth_data,subset = (Time_h != time_point), select = seq(1,length(dataset)))
      }
    }
    
    if(plot == TRUE)
    {
      par(mfrow = c(8,12), mar = c(1,1,1,1))
      for(i in 1:length(sel_wells))
      {
        sel_well = sel_wells[i]
        red_data = Red_dataset(smooth_data,sel_well)
        
        plot(red_data, ylim = c(-0.1,0.6), col = "pink", pch = 19)
      }
    }
  } #if(length(time_points)>0)
  
  if(outputfile != "")
  {write.table(smooth_data, file = outputfile,quote = FALSE, row.names = FALSE, sep = "\t")}
  
  return(smooth_data)
}

Plot_combination <- function(D_drug,R_drug,bug,list_plates,map_file_path2,Load_dir,
                             growth_window = c(0.2,0.8), lines = FALSE)
{
  Plates = grep_plates(D_drug,bug,list_plates)
  
  par(mfrow=c(1,length(Plates)), mar = c(3,2,3,2))
  for(p in 1:length(Plates))
  {
    Plate_id = Plates[p]
    inputPath = paste0(Load_dir,Plate_id,".txt",collapse=NULL)
    dataset = read.table(inputPath, header=TRUE, sep="\t", na.strings="NA", dec=".", strip.white=TRUE) 
    
    D_drug_title = paste0(D_drug, "#", substr(Plate_id,5,5),collapse=NULL)
    
    sel_wells = names(dataset)[1:length(dataset)]
    grouped_data = group_strain(dataset,map_file_path2)
    data_pos = grep(R_drug,names(grouped_data),fixed=TRUE)
    
    if(length(data_pos)>0)
    {
      colors = c("red2","darkgoldenrod1","chartreuse3")
      if(lines == TRUE)
      {
        t = "b"
      } else
      { t = "p"}
        
      for(i in 1:length(data_pos))
      {
        plot_data = as.data.frame(grouped_data[[data_pos[i]]])
        xData = as.numeric(as.vector(plot_data[[1]]))
        
        for(j in 2:length(plot_data))
        {
          yData = as.numeric(as.vector(plot_data[[j]]))
          #yData = yData - mean(c(yData[1],yData[3]))
          
          if(i == 1 && j == 2)
          {plot(xData,yData, col = colors[i], ylim = growth_window, ylab = "", xlab = "", frame = TRUE,axes = TRUE, type = t)} else
          {points(xData,yData, col = colors[i], type = t)}
        }        
      }
      title(D_drug_title, cex = 0.5, line = 0.5)
    }
  }
  R_drug_title = paste0(bug," - R: ",R_drug,collapse=NULL)
  title(R_drug_title, outer = TRUE, line = -0.7)
}

#Important note before using!
Corr_baseline_old <- function(dataset,outputfile = "") #It corrects for initial OD, as well as for OD <= 0, = 0.001!!!
{
  new_dataset = dataset
  xData = as.numeric(as.vector(dataset[[1]]))
  for(j in 2:length(dataset))
  {
    yData = as.numeric(as.vector(dataset[[j]]))
    corr_yData = yData - median(yData[2:4])
    
    for(i in 1:length(corr_yData))
    {
      if(corr_yData[i] <= 0)
      {corr_yData[i] = 0.0001}
    }
    new_dataset[[j]] = corr_yData
  }
  
  if(outputfile != "")
  {write.table(new_dataset, file = outputfile,quote = FALSE, row.names = FALSE, sep = "\t")}
  
  return(new_dataset)
}

#Important note before using!
Corr_baseline <- function(dataset,basal=c(),outputfile = "") #It corrects for initial OD, as well as for OD <= 0, = 0.001!!!
{
  new_dataset = dataset
  xData = as.numeric(as.vector(dataset[[1]]))
  for(j in 2:length(dataset))
  {
    yData = as.numeric(as.vector(dataset[[j]]))
    
    if(length(basal)==0)
    {corr_yData = yData - median(yData[2:4])} else
    {corr_yData = yData - median(yData[basal[1]:basal[2]])}
    
    for(i in 1:length(corr_yData))
    {
      if(corr_yData[i] <= 0)
      {corr_yData[i] = 0.01}
    }
    new_dataset[[j]] = corr_yData
  }
  
  if(outputfile != "")
  {write.table(new_dataset, file = outputfile,quote = FALSE, row.names = FALSE, sep = "\t")}
  
  return(new_dataset)
}

#New! With moving average for smoothing before correcting - 14-10-2014
Smooth_corr_baseline <- function(dataset,outputfile = "") #It corrects for initial OD, as well as for OD <= 0, = 0.001!!!
{
  f20 <- rep(0.5, 2)
  dataset[2:length(dataset)] = sapply(dataset[2:length(dataset)],FUN=filter,f20,method = "convolution",sides=2)
  dataset = dataset[-length(dataset[[1]]),]
  
  new_dataset = dataset
  
  xData = as.numeric(as.vector(dataset[[1]]))
  for(j in 2:length(dataset))
  {
    yData = as.numeric(as.vector(dataset[[j]]))
    #corr_yData = yData - median(yData[2:4])
    corr_yData = yData - median(yData[1])
    
    for(i in 1:length(corr_yData))
    {
      if(corr_yData[i] <= 0)
      {corr_yData[i] = 0.0001}
    }
    new_dataset[[j]] = corr_yData
  }
  
  if(outputfile != "")
  {write.table(new_dataset, file = outputfile,quote = FALSE, row.names = FALSE, sep = "\t")}
  
  return(new_dataset)
}

#Check: http://www.math.ist.utl.pt/~calves/courses/integra/capiii32.html
Trape_rule <- function(dataset)
{
  areas = c()
  
  xData = as.numeric(as.vector(dataset[[1]]))
  nr_points = length(xData)
  h = (xData[length(xData)]-xData[1])/(nr_points-1)
  
  for(i in 2:length(dataset))
  {
    yData = as.numeric(as.vector(dataset[[i]]))
    
    t = (yData[1] + yData[length(yData)])/2
    for(j in 2:(length(yData)-1))
    {
      t = t + yData[j]
    }
    
    Tn = t*h
    areas = c(areas,Tn)
  }
  names(areas) = names(dataset)[2:length(dataset)]
  return(areas)
  
}

Screen_area <- function(d_drug,bug,List_plates,map_file_path2,file_id = "", time_cutoff = 8)
{
  Plates = grep_plates(d_drug,bug,List_plates)
  table_header = c()
  table_values = c()
  
  for(p in 1:length(Plates))
  {
    Plate_id = Plates[p]
    inputPath = paste0(Load_dir,Plate_id,".txt",collapse=NULL)
    dataset = read.table(inputPath, header=TRUE, sep="\t", na.strings="NA", dec=".", strip.white=TRUE)
    
    dataset = Corr_baseline(dataset)
    
    #Reducing the dataset until time_cutoff
    lim = 0
    i = 1
    while(i < length(as.vector(dataset[[1]])))
    {
      if (as.numeric(dataset[i,1])<time_cutoff)
      {i = i+1} else
      {
        lim = i
        i = length(as.vector(dataset[[1]]))
      }
    }
    
    dataset = dataset[1:lim,]
    
    max_growth = Trape_rule(dataset)
    table_values = cbind(table_values,max_growth)
    
    drug_index = as.numeric(substr(Plate_id,3,4))
    if(drug_index != 0)
    {
      d_code = grep_exact(drug_index,D_codes)
      head = Drugs[d_code]  
    } else
    {head = "R_control"}
    head = paste0(head," ",substr(Plate_id,5,5)," rep ",substr(Plate_id,6,6),collapse = NULL)
    table_header = c(table_header,head)
  }
  
  out_data = as.data.frame(table_values)
  names(out_data) = table_header
  out_data = as.data.frame(t(out_data))
  names(out_data) = names(dataset)[2:length(dataset)]
  
  grouped_data = group_strain(out_data,map_file_path2)
  
  sorted_table = c()
  Drugs_single = c(Drugs,"SingleDrug","LB")
  
  for(d in 1:length(Drugs_single))
  {
    r_drug = Drugs_single[d]
    pos = grep(r_drug,names(grouped_data))
    
    if(length(pos)>0)
    {
      r_drug_data = c()
      for(p in 1:length(pos))
      {
        if(p == 1)
        {r_drug_data= grouped_data[[pos[p]]]} else
        {r_drug_data= cbind(r_drug_data,grouped_data[[pos[p]]])}  
      }
      
      if(r_drug != "SingleDrug" && r_drug != "LB")
      {
        new_names = sort(c(names(grouped_data)[pos],names(grouped_data)[pos]))
        n = 2
        while(n <= length(new_names))
        {
          new_names[n] = paste0(new_names[n]," rep 2",collapse = NULL)
          n = n+2
        }
        names(r_drug_data) = new_names
      } else
      {
        if(r_drug == "SingleDrug")
        {names(r_drug_data) = c("SingleDrug rep 1","SingleDrug rep 2","SingleDrug rep 3")}
        if(r_drug == "LB")
        {names(r_drug_data) = c("NoDrug rep 1","NoDrug rep 2","NoDrug rep 3")}
      }
      
      if(d == 1)
      {sorted_table = r_drug_data} else
      {sorted_table = cbind(sorted_table,r_drug_data)}
    } 
  }
  
  if(file_id != "")
  {write.table(sorted_table,file = file_id, append = FALSE, sep = "\t", quote = FALSE)} else
  {return(sorted_table)}
  
}

Screen_maxG <- function(d_drug,bug,List_plates,map_file_path2,file_id = "", time_cutoff = 8)
{
  Plates = grep_plates(d_drug,bug,List_plates)
  table_header = c()
  table_values = c()
  
  for(p in 1:length(Plates))
  {
    Plate_id = Plates[p]
    inputPath = paste0(Load_dir,Plate_id,".txt",collapse=NULL)
    dataset = read.table(inputPath, header=TRUE, sep="\t", na.strings="NA", dec=".", strip.white=TRUE)
    
    dataset = Corr_baseline(dataset)
    
    #Reducing the dataset until time_cutoff
    lim = 0
    i = 1
    while(i < length(as.vector(dataset[[1]])))
    {
      if (as.numeric(dataset[i,1])<time_cutoff)
      {i = i+1} else
      {
        lim = i
        i = length(as.vector(dataset[[1]]))
      }
    }
    
    dataset = dataset[1:lim,]
    
    max_growth = as.vector(t(dataset[lim,2:length(dataset)]))
    #max_growth = sapply(dataset[2:length(dataset)],FUN = max)
    #max_growth = Trape_rule(dataset)
    table_values = cbind(table_values,max_growth)
    
    drug_index = as.numeric(substr(Plate_id,3,4))
    if(drug_index != 0)
    {
      d_code = grep_exact(drug_index,D_codes)
      head = Drugs[d_code]  
    } else
    {head = "R_control"}
    head = paste0(head," ",substr(Plate_id,5,5)," rep ",substr(Plate_id,6,nchar(Plate_id)),collapse = NULL)
    table_header = c(table_header,head)
  }
  
  out_data = as.data.frame(table_values)
  names(out_data) = table_header
  out_data = as.data.frame(t(out_data))
  names(out_data) = names(dataset)[2:length(dataset)]
  
  grouped_data = group_strain(out_data,map_file_path2)
  
  sorted_table = c()
  Drugs_single = c(Drugs,"SingleDrug","LB")
  
  for(d in 1:length(Drugs_single))
  {
    r_drug = Drugs_single[d]
    pos = grep(r_drug,names(grouped_data))
    
    if(length(pos)>0)
    {
      r_drug_data = c()
      for(p in 1:length(pos))
      {
        if(p == 1)
        {r_drug_data= grouped_data[[pos[p]]]} else
        {r_drug_data= cbind(r_drug_data,grouped_data[[pos[p]]])}  
      }
      
      if(r_drug != "SingleDrug" && r_drug != "LB")
      {
        new_names = sort(c(names(grouped_data)[pos],names(grouped_data)[pos]))
        n = 2
        while(n <= length(new_names))
        {
          new_names[n] = paste0(new_names[n]," rep 2",collapse = NULL)
          n = n+2
        }
        names(r_drug_data) = new_names
      } else
      {
        if(r_drug == "SingleDrug")
        {names(r_drug_data) = c("SingleDrug rep 1","SingleDrug rep 2","SingleDrug rep 3")}
        if(r_drug == "LB")
        {names(r_drug_data) = c("NoDrug rep 1","NoDrug rep 2","NoDrug rep 3")}
      }
      
      if(d == 1)
      {sorted_table = r_drug_data} else
      {sorted_table = cbind(sorted_table,r_drug_data)}
    } 
  }
  
  if(file_id != "")
  {write.table(sorted_table,file = file_id, append = FALSE, sep = "\t", quote = FALSE)} else
  {return(sorted_table)}
  
}

NonLin_Rate <- function(dataset,min_growth=0.08,max_lag=8,growth_window=c(0,0.45),time_window=c(0,10),plotting=T,time_cutoff=0)
{
  xData = dataset[[1]]
  
  if(plotting==T)
  {par(mfrow=c(8,12),mar=c(1,1,1,1))}
  
  for(w in 2:length(dataset))
  {
    yData = dataset[[w]]
    if(plotting==T)
    {
      plot(xData,yData,ylim=growth_window,xlim=time_window,col="black",pch=19,cex=0.7)
      text(x=3,y=0.4,labels=names(dataset)[w])
    } #if(plotting==T)
    
    #Check for growth
    if(max(yData[grep(F,xData > max_lag)]) <= min_growth)
    {parameters=c(0,0,8,0,0,1,0,0)} else
    {
      nonlin_fit <- gcFitModel(xData, yData, gcID = "undefined",control=grofit.control(model.type=c("gompertz")))
      if(is.na(nonlin_fit$parameters[[2]][[1]])==FALSE)
      {
        fitted_point=0
        fitted_area=0
        if(time_cutoff>0)
        {
          fitted_point=nonlin_fit$fit.data[length(grep(T,nonlin_fit$fit.time<time_cutoff))+1]
          fitted_area = trap.rule(nonlin_fit$fit.time[1:(length(grep(T,nonlin_fit$fit.time<time_cutoff))+1)],
            nonlin_fit$fit.data[1:(length(grep(T,nonlin_fit$fit.time<time_cutoff))+1)])
        }
        
        if(plotting==T)
        {plot(nonlin_fit,colData="red3",ylim=growth_window,xlim=time_window,add=TRUE,pch=19,cex=0.7)} #if(plotting==T)
        
        R = cor(nonlin_fit$raw.data,nonlin_fit$fit.data)
        parameters=c(nonlin_fit$parameters[[2]][[1]],nonlin_fit$parameters[[1]][[1]],nonlin_fit$parameters[[3]][[1]],nonlin_fit$parameters[[4]][[1]],
                     sum((nonlin_fit$raw.data-nonlin_fit$fit.data)^2),R,fitted_point,fitted_area)
      } else
      {parameters=c(0,0,0,0,0,2,0,0)}
    }
    
    parameters = as.data.frame(parameters)
    row.names(parameters) = c("miu","plateauOD","lag-phase","integral","residSS","CorCoef","fitted_point","fitted_area")
    names(parameters) = names(dataset)[w]
    if(w==2)
    {Parameters = as.data.frame(t(parameters))} else
    {Parameters = as.data.frame(rbind(Parameters,t(parameters)))}
  }
  
  return(Parameters)   
}

get_comb_time_profile_obsulete <- function(bug,d_drug,r_drug,bug_cutoff,Load_dir0,Load_dir3,D_codes,Drugs,All_Bugs) #Load_dir for plates! Assuming all donor plates come from same batch
{
  map_file_path = paste0(Load_dir0,"Map_screen",".txt",collapse=NULL)
  map = read.table(map_file_path,sep="\t",header=TRUE)
  
  #get interaction matrix
  interac = as.data.frame(t(Interac_d1d2(bug,d_drug,r_drug,Load_dir3)))
  names(interac)=unlist(lapply(names(interac),FUN=getPlate_id,D_codes,Drugs,All_Bugs))
  
  batch_info = get_batch3(bug,d_drug,D_codes,Drugs,All_Bugs)
  
  if(length(unique(batch_info[3])) == 1)
  {
    batch = as.character(as.matrix(unique(batch_info[3])))
    batch_info_controls= get_batch3(bug,"Control",D_codes,Drugs,All_Bugs)
    
    #get control data - receiver
    control_plates = as.vector(batch_info_controls[grep(batch,as.vector(batch_info_controls[[3]])),2])
    control_plates_path = paste0(Load_dir0,control_plates,".txt",collapse = NULL)
    
    r_wells = as.vector(map[grep(r_drug,map[[2]]),1])
    r_drugs = as.vector(map[grep(r_drug,map[[2]]),2])
    r_concs = substr(r_drugs,nchar(r_drugs),nchar(r_drugs))
    
    for(p in 1:length(control_plates_path))
    {
      Control_data=read.table(control_plates_path[p],sep="\t",header=TRUE)
      Control_data = Smooth_corr_baseline(Control_data)
      Control_data = Control_data[c(1,grep(TRUE,names(Control_data) %in% r_wells))]
      Control_data=Control_data[c(1,2,5,3,6,4,7)]
      
      names(Control_data)[2:length(Control_data)] = r_concs
      
      if(p==1)
      {All_controls = list()}
      All_controls[[(length(All_controls)+1)]] = Control_data
    }
    names(All_controls) = control_plates
    
    #get donor and donor-receiver data
    donor_plates = as.vector(batch_info[grep(batch,as.vector(batch_info[[3]])),2])
    donor_plates_path = paste0(Load_dir0,donor_plates,".txt",collapse = NULL)
    
    dr_wells = as.vector(map[grep(r_drug,map[[2]]),1])
    dr_drugs = as.vector(map[grep(r_drug,map[[2]]),2])
    dr_concs = substr(r_drugs,nchar(r_drugs),nchar(r_drugs))
    
    d_wells = as.vector(map[grep("Single",map[[2]]),1])
    
    for(p in 1:length(donor_plates_path))
    {
      Donor_data = read.table(donor_plates_path[p],sep="\t",header=TRUE)
      Donor_data = Smooth_corr_baseline(Donor_data)
      Donor_data=Donor_data[c(1,grep(TRUE,names(Donor_data) %in% r_wells))]
      Donor_data=Donor_data[c(1,2,5,3,6,4,7)]
      names(Donor_data)[2:length(Donor_data)] = r_concs
      
      if(p==1)
      {All_doubles = list()}
      All_doubles[[(length(All_doubles)+1)]] = Donor_data
    }
    names(All_doubles) = donor_plates
    
    for(p in 1:length(donor_plates_path))
    {
      Donor_data=read.table(donor_plates_path[p],sep="\t",header=TRUE)
      Donor_data = Smooth_corr_baseline(Donor_data)
      Donor_data=Donor_data[c(1,grep(TRUE,names(Donor_data) %in% d_wells))]
      
      if(p==1)
      {All_donors = list()}
      All_donors[[(length(All_donors)+1)]] = Donor_data
    }
    names(All_donors) = donor_plates
    
    #get 1 no drug control from the first receiver plate
    n_wells = as.vector(map[grep("LB",map[[2]]),1])
    NoDrug_data=read.table(control_plates_path[1],sep="\t",header=TRUE)
    NoDrug_data = Smooth_corr_baseline(NoDrug_data)
    NoDrug_data=NoDrug_data[c(1,grep(TRUE,names(NoDrug_data) %in% n_wells))]
    cut_pos = c(grep(FALSE,bug_cutoff>NoDrug_data[[1]])-1)[1]
    
    #*********************** Start plotting
    par(mfrow=c(4,(1+length(All_donors))),mar=c(1,1,1,1))
    ywindow = c(0.0,0.5)
    
    plot(NoDrug_data[[1]],NoDrug_data[[2]], frame=TRUE,axes=FALSE,ylab="",xlab="",ylim=ywindow,xlim=c(0,11),col = "slategray", pch = 19,type="b")
    for(i in 3:length(NoDrug_data))
    {
      points(NoDrug_data[[1]],NoDrug_data[[i]],col = "slategray", pch = 19,type="b")
      points(c(NoDrug_data[cut_pos,1],NoDrug_data[cut_pos,1]),c(0,1),type="l",lty=2)
    }
    
    donors_ftnss = c()
    for(p in 1:length(All_donors))
    {
      donor_data = All_donors[[p]]
      plate = names(All_donors)[p]
      conc = as.numeric(substr(plate,5,5))
      colors=c("chartreuse4","chartreuse3","darkolivegreen3")
      cut_pos = c(grep(FALSE,bug_cutoff>donor_data[[1]])-1)[1]
      donors_ftnss = c(donors_ftnss,mean(as.numeric((donor_data[cut_pos,-1]))))
      
      plot(donor_data[[1]],donor_data[[2]], frame=TRUE,axes=FALSE,ylab="",xlab="",ylim=ywindow,xlim=c(0,11),col = colors[conc], pch = 19,type="b")
      text(x=3,y=(ywindow[2]-0.05), paste0(d_drug," ",conc,collapse = NULL),cex=0.8)
      for(i in 3:length(donor_data))
      {
        points(donor_data[[1]],donor_data[[i]],col = colors[conc], pch = 19,type="b")
        points(c(donor_data[cut_pos,1],donor_data[cut_pos,1]),c(0,1),type="l",lty=2)
      }
    }
    
    #Only for 1 control
    Rec_data = All_controls[[1]]
    for(c in 1:length(All_controls))
    {
      Rec_data = All_controls[[c]]
      cut_pos = c(grep(FALSE,bug_cutoff>Rec_data[[1]])-1)[1]
      
      if(c==1)
      {all_cutoffs = Rec_data[cut_pos,]} else
      {
        all_cutoffs = as.data.frame(rbind(all_cutoffs,Rec_data[cut_pos,]))
      }
    }
    med_controls = sapply(all_cutoffs,FUN=median)
    control_ref = grep(min(sapply(as.data.frame(abs(t(all_cutoffs[-1])-med_controls[-1])),FUN=sum)),sapply(as.data.frame(abs(t(all_cutoffs[-1])-med_controls[-1])),FUN=sum))
    Rec_data = All_controls[[control_ref]]
    cut_pos = c(grep(FALSE,bug_cutoff>Rec_data[[1]])-1)[1]
    
    
    for(conc in 1:3)
    {
      colors=c("firebrick3","firebrick2","firebrick1")
      plot(Rec_data[[1]],Rec_data[grep(conc,names(Rec_data))][[1]], frame=TRUE,axes=FALSE,ylab="",xlab="",ylim=ywindow,xlim=c(0,11),col = colors[conc], pch = 19,type="b")
      points(Rec_data[[1]],Rec_data[grep(conc,names(Rec_data))][[2]],col = colors[conc], pch = 1,type="b")
      points(c(Rec_data[cut_pos,1],Rec_data[cut_pos,1]),c(0,1),type="l",lty=2)
      points(c(Rec_data[cut_pos,1]),c(med_controls[grep(conc,names(med_controls))][[1]]),col="black",pch=19)
      points(c(Rec_data[cut_pos,1]),c(med_controls[grep(conc,names(med_controls))][[2]]),col="black",pch=1)
      text(x=3,y=(ywindow[2]-0.05), paste0(r_drug," ",conc,collapse = NULL),cex=0.8)
      
      interac_conc = interac[grep(paste0(r_drug," ",conc,collapse = NULL),row.names(interac)),]
      
      for(p in 1:length(All_doubles))
      {
        plate_id = names(All_doubles)[p]
        interac_data = interac_conc[grep(plate_id,names(interac_conc))]
        
        double_data = All_doubles[[p]]
        double_data = double_data[c(1,grep(conc,names(double_data)))]
        cut_pos_double = c(grep(FALSE,bug_cutoff>double_data[[1]])-1)[1]
        
        plot(double_data[[1]],double_data[[2]], frame=TRUE,axes=FALSE,ylab="",xlab="",ylim=ywindow,xlim=c(0,11),col = "black", pch = 19,type="b")
        points(double_data[[1]],double_data[[3]],col = "black", pch = 1,type="b")
        points(c(double_data[cut_pos_double,1],double_data[cut_pos_double,1]),c(0,1),type="l",lty=2)
        
        text(x=3,y=(ywindow[2]-0.05),"IntScore",cex=0.8)
        text(x=3,y=(ywindow[2]-0.1),round(interac_data[1,],2),cex=0.8)
        text(x=3,y=(ywindow[2]-0.15),round(interac_data[2,],2),cex=0.8)
      }
    }
  } else
  {return("Donor experiments were done with different batches")}
}

#New! Fixed the previous one from some bugs and added the interaction scores to plots.
#Works very well for ST. 14-10-2014
get_comb_time_profile <- function(bug,d_drug,r_drug,bug_cutoff,Load_dir0,Load_dir3,D_codes,Drugs,All_Bugs) #Load_dir for plates! Assuming all donor plates come from same batch
{
  map_file_path = paste0(Load_dir0,"Map_screen",".txt",collapse=NULL)
  map = read.table(map_file_path,sep="\t",header=TRUE)
  
  #get interaction matrix
  interac = as.data.frame(t(Interac_d1d2(bug,d_drug,r_drug,Load_dir3)))
  names(interac)=unlist(lapply(names(interac),FUN=getPlate_id,D_codes,Drugs,All_Bugs))
  
  batch_info = get_batch3(bug,d_drug,D_codes,Drugs,All_Bugs)
  
  if(length(unique(batch_info[3])) == 1)
  {
    batch = as.character(as.matrix(unique(batch_info[3])))
    batch_info_controls= get_batch3(bug,"Control",D_codes,Drugs,All_Bugs)
    
    #get control data - receiver
    control_plates = as.vector(batch_info_controls[grep(batch,as.vector(batch_info_controls[[3]])),2])
    control_plates_path = paste0(Load_dir0,control_plates,".txt",collapse = NULL)
    
    r_wells = as.vector(map[grep(r_drug,map[[2]]),1])
    r_drugs = as.vector(map[grep(r_drug,map[[2]]),2])
    r_concs = substr(r_drugs,nchar(r_drugs),nchar(r_drugs))
    
    for(p in 1:length(control_plates_path))
    {
      Control_data=read.table(control_plates_path[p],sep="\t",header=TRUE)
      Control_data = Smooth_corr_baseline(Control_data)
      Control_data = Control_data[c(1,grep(TRUE,names(Control_data) %in% r_wells))]
      Control_data=Control_data[c(1,2,5,3,6,4,7)]
      
      names(Control_data)[2:length(Control_data)] = r_concs
      
      if(p==1)
      {All_controls = list()}
      All_controls[[(length(All_controls)+1)]] = Control_data
    }
    names(All_controls) = control_plates
    
    #get donor and donor-receiver data
    donor_plates = as.vector(batch_info[grep(batch,as.vector(batch_info[[3]])),2])
    donor_plates_path = paste0(Load_dir0,donor_plates,".txt",collapse = NULL)
    
    dr_wells = as.vector(map[grep(r_drug,map[[2]]),1])
    dr_drugs = as.vector(map[grep(r_drug,map[[2]]),2])
    dr_concs = substr(r_drugs,nchar(r_drugs),nchar(r_drugs))
    
    d_wells = as.vector(map[grep("Single",map[[2]]),1])
    
    for(p in 1:length(donor_plates_path))
    {
      Donor_data = read.table(donor_plates_path[p],sep="\t",header=TRUE)
      Donor_data = Smooth_corr_baseline(Donor_data)
      Donor_data=Donor_data[c(1,grep(TRUE,names(Donor_data) %in% r_wells))]
      Donor_data=Donor_data[c(1,2,5,3,6,4,7)]
      names(Donor_data)[2:length(Donor_data)] = r_concs
      
      if(p==1)
      {All_doubles = list()}
      All_doubles[[(length(All_doubles)+1)]] = Donor_data
    }
    names(All_doubles) = donor_plates
    
    for(p in 1:length(donor_plates_path))
    {
      Donor_data=read.table(donor_plates_path[p],sep="\t",header=TRUE)
      Donor_data = Smooth_corr_baseline(Donor_data)
      Donor_data=Donor_data[c(1,grep(TRUE,names(Donor_data) %in% d_wells))]
      
      if(p==1)
      {All_donors = list()}
      All_donors[[(length(All_donors)+1)]] = Donor_data
    }
    names(All_donors) = donor_plates
    
    #get 1 no drug control from the first receiver plate
    n_wells = as.vector(map[grep("LB",map[[2]]),1])
    NoDrug_data=read.table(control_plates_path[1],sep="\t",header=TRUE)
    NoDrug_data = Smooth_corr_baseline(NoDrug_data)
    NoDrug_data=NoDrug_data[c(1,grep(TRUE,names(NoDrug_data) %in% n_wells))]
    cut_pos = c(grep(FALSE,bug_cutoff>NoDrug_data[[1]])-1)[1]
    
    #*********************** Start plotting
    par(mfrow=c(4,(1+length(All_donors))),mar=c(1,1,1,1))
    ywindow = c(0.0,0.5)
    
    plot(NoDrug_data[[1]],NoDrug_data[[2]], frame=TRUE,axes=FALSE,ylab="",xlab="",ylim=ywindow,xlim=c(0,11),col = "slategray", pch = 19,type="b")
    for(i in 3:length(NoDrug_data))
    {
      points(NoDrug_data[[1]],NoDrug_data[[i]],col = "slategray", pch = 19,type="b")
      points(c(NoDrug_data[cut_pos,1],NoDrug_data[cut_pos,1]),c(0,1),type="l",lty=2)
    }
    
    donors_ftnss = c()
    for(p in 1:length(All_donors))
    {
      donor_data = All_donors[[p]]
      plate = names(All_donors)[p]
      conc = as.numeric(substr(plate,5,5))
      colors=c("chartreuse4","chartreuse3","darkolivegreen3")
      cut_pos = c(grep(FALSE,bug_cutoff>donor_data[[1]])-1)[1]
      donors_ftnss = c(donors_ftnss,mean(as.numeric((donor_data[cut_pos,-1]))))
      
      plot(donor_data[[1]],donor_data[[2]], frame=TRUE,axes=FALSE,ylab="",xlab="",ylim=ywindow,xlim=c(0,11),col = colors[conc], pch = 19,type="b")
      text(x=3,y=(ywindow[2]-0.05), paste0(d_drug," ",conc,collapse = NULL),cex=0.8)
      for(i in 3:length(donor_data))
      {
        points(donor_data[[1]],donor_data[[i]],col = colors[conc], pch = 19,type="b")
        points(c(donor_data[cut_pos,1],donor_data[cut_pos,1]),c(0,1),type="l",lty=2)
      }
    }
    
    #Control data
    if(length(All_controls)>2)
    {
      Rec_data = All_controls[[1]]
      for(c in 1:length(All_controls))
      {
        Rec_data = All_controls[[c]]
        cut_pos = c(grep(FALSE,bug_cutoff>Rec_data[[1]])-1)[1]
        
        if(c==1)
        {all_cutoffs = Rec_data[cut_pos,]} else
        {
          all_cutoffs = as.data.frame(rbind(all_cutoffs,Rec_data[cut_pos,]))
        }
      }
      med_controls = sapply(all_cutoffs,FUN=median)
      control_ref = grep(min(sapply(as.data.frame(abs(t(all_cutoffs[-1])-med_controls[-1])),FUN=sum)),sapply(as.data.frame(abs(t(all_cutoffs[-1])-med_controls[-1])),FUN=sum))
      Rec_data = All_controls[[control_ref]]
      cut_pos = c(grep(FALSE,bug_cutoff>Rec_data[[1]])-1)[1]
    } else
    {
      Rec_data = All_controls[[1]]
      cut_pos = c(grep(FALSE,bug_cutoff>Rec_data[[1]])-1)[1]
      med_controls = Rec_data[cut_pos,]
    }
    
    for(conc in 1:3)
    {
      colors=c("firebrick3","firebrick2","firebrick1")
      plot(Rec_data[[1]],Rec_data[grep(conc,names(Rec_data))][[1]], frame=TRUE,axes=FALSE,ylab="",xlab="",ylim=ywindow,xlim=c(0,11),col = colors[conc], pch = 19,type="b")
      points(Rec_data[[1]],Rec_data[grep(conc,names(Rec_data))][[2]],col = colors[conc], pch = 1,type="b")
      points(c(Rec_data[cut_pos,1],Rec_data[cut_pos,1]),c(0,1),type="l",lty=2)
      points(c(Rec_data[cut_pos,1]),c(med_controls[grep(conc,names(med_controls))][[1]]),col="black",pch=19)
      points(c(Rec_data[cut_pos,1]),c(med_controls[grep(conc,names(med_controls))][[2]]),col="black",pch=1)
      text(x=3,y=(ywindow[2]-0.05), paste0(r_drug," ",conc,collapse = NULL),cex=0.8)
      
      interac_conc = interac[grep(paste0(r_drug," ",conc,collapse = NULL),row.names(interac)),]
      
      for(p in 1:length(All_doubles))
      {
        plate_id = names(All_doubles)[p]
        interac_data = interac_conc[grep(plate_id,names(interac_conc))]
        
        double_data = All_doubles[[p]]
        double_data = double_data[c(1,grep(conc,names(double_data)))]
        cut_pos_double = c(grep(FALSE,bug_cutoff>double_data[[1]])-1)[1]
        
        plot(double_data[[1]],double_data[[2]], frame=TRUE,axes=FALSE,ylab="",xlab="",ylim=ywindow,xlim=c(0,11),col = "black", pch = 19,type="b")
        points(double_data[[1]],double_data[[3]],col = "black", pch = 1,type="b")
        points(c(double_data[cut_pos_double,1],double_data[cut_pos_double,1]),c(0,1),type="l",lty=2)
        
        text(x=3,y=(ywindow[2]-0.05),"IntScore",cex=0.8)
        text(x=3,y=(ywindow[2]-0.1),round(interac_data[1,],2),cex=0.8)
        text(x=3,y=(ywindow[2]-0.15),round(interac_data[2,],2),cex=0.8)
      }
    }
  } else
  {return("Donor experiments were done with different batches")}
}


# ======================= Network analysis =================

get_Classes_simm_heatmap_new <- function(bug,complete_Hits=c(),Hits=c(),Attr_table,Drug_classes="Class",plotting=TRUE,plotting2=FALSE,reporting=TRUE)
{
  if(length(complete_Hits)==0 && length(Hits)==0)
  {return("No Hit-list provided.")} else
  {
    if(length(complete_Hits)>0)
    {
      Hits = as.data.frame(cbind(as.character(as.matrix(complete_Hits[[1]])),as.character(as.matrix(complete_Hits[[9]])),
                                 as.character(as.matrix(complete_Hits[[2]])),paste0(complete_Hits[[1]],"_",complete_Hits[[2]])))
      names(Hits) = c("DrugA","Interaction","DrugB","DrugA_B")
    }
    
    col_antagonism = "#FF9A39"
    col_synergy = "#04859D"
    
    header = names(Hits)
    nr_hits = length(Hits[[1]])
    Hits = as.matrix(Hits)
    for(h in 1:nr_hits)
    {
      hit_donor = Hits[h,1]
      hit_recei = Hits[h,3]
      
      Hits[h,1] = as.character(Attr_table[grep_exact(hit_donor,as.character(as.vector(Attr_table[[1]]))),grep_exact(Drug_classes,names(Attr_table))])
      Hits[h,3] = as.character(Attr_table[grep_exact(hit_recei,as.character(as.vector(Attr_table[[1]]))),grep_exact(Drug_classes,names(Attr_table))])
      Hits[h,4] = paste0(Hits[h,1],"_",Hits[h,3],collapse = NULL)
    }
    
    Hits = as.data.frame(Hits)
    names(Hits) = header 
    
    uniq_classes = as.character(unique(Attr_table[[grep_exact(Drug_classes,names(Attr_table))]]))
    
    Adj_matrix = matrix(data=0,nrow = length(uniq_classes),nc=length(uniq_classes))
    Adj_matrix_neg = matrix(data=0,nrow = length(uniq_classes),nc=length(uniq_classes))
    Adj_matrix_pos = matrix(data=0,nrow = length(uniq_classes),nc=length(uniq_classes))
    
    for(c in 1:length(uniq_classes))
    {
      drug = uniq_classes[c]
      
      if(length(c(grep_exact(drug,Hits[[1]]),grep_exact(drug,Hits[[3]])))>0)
      {
        class_hits = Hits[unique(c(grep_exact(drug,Hits[[1]]),grep_exact(drug,Hits[[3]]))),]
        Hits = Hits[-unique(c(grep_exact(drug,Hits[[1]]),grep_exact(drug,Hits[[3]]))),]
        
        outer_hits = c(as.vector(class_hits[grep(FALSE,drug == class_hits[[1]]),1]),as.vector(class_hits[grep(FALSE,drug == class_hits[[3]]),3]))
        outer_direct = c(as.vector(class_hits[grep(FALSE,drug == class_hits[[1]]),2]),as.vector(class_hits[grep(FALSE,drug == class_hits[[3]]),2]))
        
        inner_hits = class_hits[drug == class_hits[[1]],]
        inner_hits = inner_hits[drug == inner_hits[[3]],]
        inner_direct = as.character(as.vector(inner_hits[[2]]))
        
        all_hits = c(outer_hits,as.character(as.vector(inner_hits[[1]])))
        all_directions = c(outer_direct,inner_direct)
        
        for(cc in 1:length(uniq_classes))
        {
          class = uniq_classes[cc]
          int = length(grep_exact(class,all_hits))
          directions = all_directions[grep_exact(class,all_hits)]
          direc_pos = length(grep("Antagonism",directions))
          direc_neg = length(grep("Synergy",directions))
          
          Adj_matrix[cc,c] = int
          Adj_matrix_pos[cc,c] = direc_pos
          Adj_matrix_neg[cc,c] = direc_neg
          
        }
      }
      
    }
    Adj_matrix = as.data.frame(Adj_matrix)
    names(Adj_matrix) = uniq_classes
    row.names(Adj_matrix) = uniq_classes
    
    Adj_matrix_pos = as.data.frame(Adj_matrix_pos)
    names(Adj_matrix_pos) = uniq_classes
    row.names(Adj_matrix_pos) = uniq_classes
    
    Adj_matrix_neg = as.data.frame(Adj_matrix_neg)
    names(Adj_matrix_neg) = uniq_classes
    row.names(Adj_matrix_neg) = uniq_classes
    
    if(plotting2==TRUE)
    {
      #********** Plot heatmap for total nr of interactions
      par(mfrow=c(1,1),mar=c(2,2,2,2))
      corrplot_col = colorRampPalette(c("white","white","dodgerblue"))(max(as.matrix(Adj_matrix)))
      corrplot(as.matrix((Adj_matrix)),tl.cex=0.8,tl.col="black", mar=c(0.5,0.5,0,0.5), type="lower",
               is.corr=FALSE,method="color",col=corrplot_col,tl.srt=45)
      title(main="Total interactions between classes",cex.main=1, font.main=1,line=-4)
      title(bug,line=-2)
      
      #********** Plot heatmap with positive and negative
      #Transpose Adj_matrix_pos!
      corrplot_col = colorRampPalette(c(col_synergy,"white",col_antagonism))(11)
      par(mfrow=c(1,2),mar=c(4,4,4,4))
      corrplot(-as.matrix(Adj_matrix_neg)/max(abs(as.matrix(Adj_matrix_neg))),type="lower",
               tl.cex=0.7,tl.col="black", col=corrplot_col,tl.pos="n",mar=c(1,1,1,0),cl.pos="b",cl.cex = 0.6)
      
      for(c in 1:(length(uniq_classes)/2))
      {
        class=uniq_classes[c]
        n = length(grep_exact(class,Attr_table[[grep_exact(Drug_classes,names(Attr_table))]]))
        hight = length(uniq_classes)-c+1
        x_pos = c+1
        text(x=x_pos,y=hight,labels=paste0(class,", n=",n),adj=0,cex=0.8)
      }
      title("Synergies",cex.main=0.9,line=-5)
      corrplot(as.matrix(t(Adj_matrix_pos))/max(abs(as.matrix(Adj_matrix_pos))),type="upper",
               tl.cex=0.7,tl.col="black", col=corrplot_col,tl.pos="n",mar=c(1,0,1,1),cl.pos="b",cl.cex = 0.6)
      x_pos = length(uniq_classes)/2
      for(c in (length(uniq_classes)/2+1):length(uniq_classes))
      {
        class=uniq_classes[c]
        n = length(grep_exact(class,Attr_table[[grep_exact(Drug_classes,names(Attr_table))]]))
        hight = length(uniq_classes)-c+1
        text(x=x_pos,y=hight,labels=paste0(class,", n=",n),adj=1,cex=0.8)
        x_pos = x_pos+1
      }
      title("Antagonisms",cex.main=0.9,line=-5)
      title(bug,outer=T,line=-2)
    }
    
    #************** Make output table
    within_neg=sum(diag(as.matrix(Adj_matrix_neg)))
    within_pos=sum(diag(as.matrix(Adj_matrix_pos)))
    all_pos = sum(as.vector(as.matrix(Adj_matrix_pos)))
    all_neg = sum(as.vector(as.matrix(Adj_matrix_neg)))
    
    conting_table = matrix(0,nrow = 3,ncol = 3)
    conting_table[1,1] = within_pos
    conting_table[1,2] = within_neg
    conting_table[1,3] = within_pos + within_neg
    conting_table[2,1] = all_pos - within_pos
    conting_table[2,2] = all_neg - within_neg
    conting_table[2,3] = conting_table[2,1] + conting_table[2,2]
    conting_table[3,1] = all_pos
    conting_table[3,2] = all_neg
    conting_table[3,3] = conting_table[3,1] + conting_table[3,2]
    
    conting_table = as.data.frame(conting_table)
    names(conting_table) = c("Positive","Negative","Total")
    row.names(conting_table) = c("Within","Across","Total")
    
    if(plotting==TRUE)
    {
      par(mfrow = c(1,1),mar=c(6,6,6,6))
      barplot(t(as.matrix(conting_table[1:2,1:2])),beside = T,col=c(col_antagonism,col_synergy),
              ylab="Interactions",main=bug,ylim=c(0,250))
    }
    
    if(reporting==TRUE)
    {
      #report
      par(mfrow=c(1,1),mar=c(4,4,4,4))
      plot(c(0,0),c(0,0), type="n",axes = FALSE,frame=FALSE,ylab="",xlab="",ylim=c(-1.5,1.5),xlim=c(-1.5,1.5))
      text(x=-1,y=1,labels="",adj=0)
      text(x=-0.5,y=1,labels="Positive",adj=0)
      text(x=0,y=1,labels="Negative",adj=0)
      text(x=0.5,y=1,labels="Total",adj=0)
      points(c(-1,1),c(0.8,0.8),type="l")
      
      text(x=-1,y=0.5,labels="Within",adj=0)
      text(x=-1,y=0,labels="Across",adj=0)
      text(x=-1,y=-0.5,labels="Total",adj=0)
      points(c(-0.6,-0.6),c(-0.8,1),type="l")
      
      text(x=-0.5,y=0.5,labels=conting_table[1,1],adj=0)
      text(x=0,y=0.5,labels=conting_table[1,2],adj=0)
      text(x=0.5,y=0.5,labels=conting_table[1,3],adj=0)
      
      text(x=-0.5,y=0,labels=conting_table[2,1],adj=0)
      text(x=0,y=0,labels=conting_table[2,2],adj=0)
      text(x=0.5,y=0,labels=conting_table[2,3],adj=0)
      points(c(-1,1),c(-0.3,-0.3),type="l")
      
      text(x=-0.5,y=-0.5,labels=conting_table[3,1],adj=0)
      text(x=0,y=-0.5,labels=conting_table[3,2],adj=0)
      text(x=0.5,y=-0.5,labels=conting_table[3,3],adj=0)
      
      points(c(0.4,0.4),c(-0.8,1),type="l")
      
      title(bug)
      title("Contingency table",line=1,font.main=1)
    }
    
    
    #******************** Prepare data to return
    
    ClassInter_tables = list(Adj_matrix,Adj_matrix_pos,Adj_matrix_neg,conting_table)
    names(ClassInter_tables) = c("ClassInter","ClassInterPos","ClassInterNeg","ContingencyTable")
    
    return(ClassInter_tables)
  }
  
} #May 17

get_Classes_network <- function(bug,ClassesInter_Tables,Classes,Class_colors,colored=TRUE,cytoscape_files=F,thick_factor=0.5)
{
  col_antagonism = "#FF9A39"
  col_synergy = "#04859D"
  
  Adj_matrix_pos = ClassesInter_Tables$ClassInterPos
  Adj_matrix_neg = ClassesInter_Tables$ClassInterNeg
  
  g_pos = graph.adjacency(as.matrix(Adj_matrix_pos), mode="undirected")
  V(g_pos)$name = row.names(Adj_matrix_pos)
  Edge_list = as.data.frame(get.edgelist(g_pos, names=TRUE))
  
  Edge_list_connect = paste0(Edge_list[[1]],"_",Edge_list[[2]],collapse = NULL)
  Edge_list_unique = unique(Edge_list_connect)
  Thickness = c()
  for(e in 1:length(Edge_list_unique))
  {
    edge = Edge_list_unique[e]
    Thickness = c(Thickness,length(grep_exact(edge,Edge_list_connect)))
  }
  
  if(cytoscape_files==T)
  {
    drug1 = unlist(strsplit(Edge_list_unique,split="_"))[seq(1,length(unlist(strsplit(Edge_list_unique,split="_"))),by=2)]
    drug2 = unlist(strsplit(Edge_list_unique,split="_"))[seq(2,length(unlist(strsplit(Edge_list_unique,split="_"))),by=2)]
    interac_net = rep("Antagonism",length(drug1))
    cytoscape_network=as.data.frame(cbind(drug1,interac_net,drug2,Thickness))
  }
  
  Thickness = Thickness*thick_factor
  
  Edge_list_unique = strsplit(Edge_list_unique,split="_")
  g_pos = unlist(Edge_list_unique)[seq(1,length(unlist(Edge_list_unique)),by=2)]
  g_pos = cbind(g_pos,unlist(Edge_list_unique)[seq(2,length(unlist(Edge_list_unique)),by=2)])
  g_pos = cbind(g_pos,Thickness,rep(col_antagonism,length(Thickness)))
  
  #Expand netwrok for negatives
  g_neg = graph.adjacency(as.matrix(Adj_matrix_neg), mode="undirected")
  V(g_neg)$name = row.names(Adj_matrix_neg)
  Edge_list = as.data.frame(get.edgelist(g_neg, names=TRUE))
  
  Edge_list_connect = paste0(Edge_list[[1]],"_",Edge_list[[2]],collapse = NULL)
  Edge_list_unique = unique(Edge_list_connect)
  Thickness = c()
  for(e in 1:length(Edge_list_unique))
  {
    edge = Edge_list_unique[e]
    Thickness = c(Thickness,length(grep_exact(edge,Edge_list_connect)))
  }
  
  if(cytoscape_files==T)
  {
    drug1 = unlist(strsplit(Edge_list_unique,split="_"))[seq(1,length(unlist(strsplit(Edge_list_unique,split="_"))),by=2)]
    drug2 = unlist(strsplit(Edge_list_unique,split="_"))[seq(2,length(unlist(strsplit(Edge_list_unique,split="_"))),by=2)]
    interac_net = rep("Synergy",length(drug1))
    cytoscape_network=as.data.frame(rbind(cytoscape_network,
                                           as.data.frame(cbind(drug1,interac_net,drug2,Thickness))))
  }
  
  Thickness = Thickness*thick_factor
  
  Edge_list_unique = strsplit(Edge_list_unique,split="_")
  g_neg = unlist(Edge_list_unique)[seq(1,length(unlist(Edge_list_unique)),by=2)]
  g_neg = cbind(g_neg,unlist(Edge_list_unique)[seq(2,length(unlist(Edge_list_unique)),by=2)])
  g_neg = cbind(g_neg,Thickness,rep(col_synergy,length(Thickness)))
  
  g_el = as.data.frame(rbind(g_neg,g_pos))
  
  g=graph.edgelist(as.matrix(g_el[,1:2]), directed=FALSE)
    
  borders=c()
  for(v in 1:length(V(g)))
  {
    vertex= V(g)$name[v]
    V(g)$color[v] = Class_colors[grep_exact(vertex,Classes)]
    borders=c(borders,V(g)$color[v])
  }
  E(g)$color = as.matrix(g_el[,4])
  E(g)$width=as.numeric(as.matrix((g_el[,3])))
  
  node_size = V(g)$name
  bug_drugs = Attr_table$Drug
  if(length(grep_exact("beta-lactam",node_size))>0)
  {bug_classes = as.vector(Attr_table[match(bug_drugs,Attr_table[[1]]),2])} else
  {bug_classes = as.vector(Attr_table[match(bug_drugs,Attr_table[[1]]),3])}
    
  for(n in 1:length(node_size))
  {
    class = node_size[n]
    node_size[n] = length(grep_exact(class,bug_classes))
  }
  
  V(g)$size = as.character(as.numeric(node_size)*1)
  
  if(cytoscape_files==T)
  {
    node_att = as.data.frame(cbind(V(g)$name,node_size))
    names(node_att) = c("Drug","Node_size")
  }
  
  radian.rescale <- function(x, start=0, direction=1) {
    c.rotate <- function(x) (x + start) %% (2 * pi) * direction
    c.rotate(scales::rescale(x, c(0, 2 * pi), range(x)))
  }
  lab.locs <- radian.rescale(x=1:n, direction=-1, start=0)
  rad=1
  
  if(colored==TRUE)
  {
    plot(g,layout=layout.circle,vertex.size=as.numeric(V(g)$size),xlim = c(-rad,rad),ylim = c(-rad,rad),vertex.frame.color= borders,vertex.label.family= 'Helvetica',
         vertex.label.cex=1,vertex.label.font=1,vertex.label.color="black",vertex.label.dist=0.4,vertex.label.degree=lab.locs)
    title(bug)
  } else
  {
    V(g)$color = "white"
    rad = 1
    plot(g,layout=layout.circle,vertex.size=20,xlim = c(-rad,rad),ylim = c(-rad,rad),vertex.frame.color= borders,vertex.label.family= 'Helvetica',
         vertex.label.cex=1,vertex.label.font=2,vertex.label.color=borders)
    title(bug)
  }
  
  if(cytoscape_files == T)
  {
    cytoscape = list(cytoscape_network,node_att)
    names(cytoscape) = c("network","node_attributes")
    return(cytoscape)
  }
  
}

get_network_conserved_Hits <- function(bug,Hits,Attr_table,Classes,Class_colors,
                                       plotting=TRUE,rad = 1,node_size = 8,node_cex = 0.7) #Sept-16
{
  #Plotting colors
  col_antagonism = "#FF9A39"
  col_synergy = "#04859D"
  #col_antagonism = "#02505E"
  #col_synergy = "#8A0025"
  new_Hits=Hits
  #Make adjacent matrix
  Adj_matrix = matrix(data=0,nrow = length(Attr_table[[1]]),nc=length(Attr_table[[1]]))
  for(h in 1:length(new_Hits[[1]]))
  {
    drug1 = as.character(new_Hits[h,1])
    drug2 = as.character(new_Hits[h,3])
    direction = as.character(new_Hits[h,grep("Interaction",names(new_Hits))])
    
    if(direction=="Antagonism")
    {Adj_matrix[grep(drug1,Attr_table[[1]]),grep(drug2,Attr_table[[1]])]=1}
    if(direction=="Synergy")
    {Adj_matrix[grep(drug1,Attr_table[[1]]),grep(drug2,Attr_table[[1]])]=1}  
  }
  g = graph.adjacency(Adj_matrix, mode="undirected")
  V(g)$name = as.character(as.vector(Attr_table[[1]]))
  
  Adj_matrix = as.data.frame(Adj_matrix)
  names(Adj_matrix) = as.character(as.vector(Attr_table[[1]]))
  row.names(Adj_matrix) = as.character(as.vector(Attr_table[[1]]))
  
  #Set the colors of each vertex according to class
  for(v in 1:length(V(g)$name))
  {
    drug = V(g)$name[v]
    class = as.character(Attr_table[grep(drug,as.character(as.vector(Attr_table[[1]]))),2])
    color = Class_colors[grep_exact(class,Classes)]
    V(g)$color[v] = color
  }
  
  #Get Nodes (vertexes) atributes - Class - Only formality
  g <- set.vertex.attribute(g,"Class",1,"Class")
  for(v in 1:length(V(g)))
  {
    node = V(g)[v]$name
    class = as.character(Attr_table[grep(node,as.character(as.vector(Attr_table[[1]]))),2])
    g <- set.vertex.attribute(g,"Class",v,class)
  }
  list.vertex.attributes(g)
  get.vertex.attribute(g,"Class")
  
  #Get interaction color based on "direction"
  Edge_list = as.data.frame(get.edgelist(g, names=TRUE))
  Direction = c()
  for(e in 1:length(Edge_list[[1]]))
  {
    drug1 = as.character(Edge_list[e,1])
    drug2 = as.character(Edge_list[e,2])
    if(length(grep(paste0(drug1,"_",drug2),paste0(new_Hits[[1]],"_",new_Hits[[3]])))>0)
    {
      pos = grep(paste0(drug1,"_",drug2),paste0(new_Hits[[1]],"_",new_Hits[[3]]))
      direction = as.character(new_Hits[[pos,grep("Interaction",names(new_Hits))]])
    } else
    {
      pos = grep(paste0(drug2,"_",drug1),paste0(new_Hits[[1]],"_",new_Hits[[3]]))
      direction = as.character(new_Hits[[pos,grep("Interaction",names(new_Hits))]])
    }
    
    Direction = c(Direction,direction)
  }
  Edge_list = as.data.frame(cbind(Edge_list,Direction))
  
  E(g)$color=ifelse(Direction=="Synergy",col_synergy,col_antagonism)
  
  if(plotting==TRUE)
  {
    plot(g,layout=layout.circle,vertex.size=node_size,xlim = c(-rad,rad),ylim = c(-rad,rad),vertex.frame.color= "white",
         vertex.label.cex=node_cex,vertex.label.font=1,vertex.label.color="black")
    
    title(bug)
  }
  
  return(g)
  
}

# ======================= Sensitivity analysis =================

Sensitivity_aux <- function(multpTest_cutoff,interac_cutoff,weak_interac_cutoff,Benchmarking_file,
                            opposite_control=T, #both, complete or reduced
                            range = "both",exp_fit_threshold = 0.2)
{
  #=============== Get strong synergies & antagonisms ========
  exp_fit_threshold_syn = exp_fit_threshold
  exp_fit_threshold_antag = 1- exp_fit_threshold
  
  #Obtain Q1, Q3 & p-vals
  for(b in 1:length(Interac_distrib))
  {
    bug = names(Interac_distrib)[b]
    bug_Interac_distrib = Interac_distrib[[b]]
    #bug_pvals = P_values[[b]]
    #names(bug_pvals) = c("CompleteConcRange","AntagConcRange","SynConcRange","AntagPot","SynPot")
    
    file_id= paste0(P_vals_dir,"P-vals_",bug,"_",exp_fit_threshold,".txt")
    bug_pvals = read.table(file_id,header=T, sep="\t", na.strings="NA", dec=".", strip.white=T)
    bug_pvals = bug_pvals[c(1,3,5,2,4)]
    names(bug_pvals) = c("CompleteConcRange","AntagConcRange","SynConcRange","AntagPot","SynPot")
    
    combs = names(bug_Interac_distrib)
    bug_pvals = bug_pvals[match(combs,row.names(bug_pvals)),]
    
    bug_Q1 = as.vector(unlist(lapply(bug_Interac_distrib,FUN=quantile,probs=c(0.25))))
    bug_Q3 = as.vector(unlist(lapply(bug_Interac_distrib,FUN=quantile,probs=c(0.75))))
    bug_int_score = bug_Q3
    bug_int_score[grep(T,abs(bug_Q1) > abs(bug_Q3))] = bug_Q1[grep(T,abs(bug_Q1) > abs(bug_Q3))]
    bug_median = as.vector(unlist(lapply(bug_Interac_distrib,FUN=quantile,probs=c(0.5))))
    
    #Reduce to relevant conc
    bug_exp_fit = Exp_fit_dist[[b]]
    
    bug_Interac_distrib_Syn = list() #Only for drug concenentrations relevant for Synergy
    bug_Interac_distrib_Antag = list() #Only for drug concenentrations relevant for Antagonism
    for(c in 1:length(bug_Interac_distrib))
    {
      comb_exp_fit = bug_exp_fit[[c]]
      comb_exp_fit[comb_exp_fit>1] = 1
      comb_Interac_distrib = bug_Interac_distrib[[c]]
      
      comb_Interac_distrib_syn = comb_Interac_distrib[comb_exp_fit>exp_fit_threshold_syn]
      comb_Interac_distrib_antag = comb_Interac_distrib[comb_exp_fit<exp_fit_threshold_antag]
      
      bug_Interac_distrib_Syn[[length(bug_Interac_distrib_Syn)+1]] = comb_Interac_distrib_syn
      bug_Interac_distrib_Antag[[length(bug_Interac_distrib_Antag)+1]] =  comb_Interac_distrib_antag
    }
    names(bug_Interac_distrib_Syn) = combs
    names(bug_Interac_distrib_Antag) = combs
    bug_Q1_reduced = as.vector(unlist(lapply(bug_Interac_distrib_Syn,FUN=quantile,probs=c(0.25),na.rm=T)))
    bug_Q3_reduced = as.vector(unlist(lapply(bug_Interac_distrib_Antag,FUN=quantile,probs=c(0.75),na.rm=T)))
    
    bug_interactions = as.data.frame(cbind(bug_Q1,bug_Q3,bug_Q1_reduced,bug_Q3_reduced,bug_pvals,bug_int_score,bug_median))
    row.names(bug_interactions) = combs
    
    if(b==1)
    {Interaction_Qs = list()}
    Interaction_Qs[[length(Interaction_Qs)+1]] = bug_interactions
    
  }
  names(Interaction_Qs) = names(Interac_distrib)
  #clean up
  rm(bug_Interac_distrib,bug_exp_fit,bug_Q1,bug_Q3,bug_pvals,bug_Q1_reduced,bug_Q3_reduced,c,b)
  rm(comb_exp_fit,comb_Interac_distrib,comb_Interac_distrib_syn,comb_Interac_distrib_antag,bug_Interac_distrib_Syn,
     bug_Interac_distrib_Antag,bug_int_score)
  
  #Correct for multiple testing: fdr & classify interactions
  for(b in 1:length(Interaction_Qs))
  {
    bug = names(Interaction_Qs)[b]
    bug_interactions = Interaction_Qs[[b]]
    
    #Correct for multiple testing
    bug_interactions[5:7] = sapply(bug_interactions[5:7],FUN=p.adjust,method = "BH")
    
    if(min(as.matrix(bug_interactions[5:7]),na.rm=T)>multpTest_cutoff)
    {multpTest_cutoff = min(as.matrix(bug_interactions[5:7]),na.rm=T)}
    
    #Assign interactions
    bug_interactions_sign = bug_interactions[bug_interactions$CompleteConcRange<=multpTest_cutoff,]
    #bug_interactions_sign = bug_interactions[bug_interactions$AntagConcRange<=multpTest_cutoff,]
    
    bug_interactions_sign = as.data.frame(rbind(bug_interactions_sign,
                                                bug_interactions[bug_interactions$SynConcRange<=multpTest_cutoff,]))
    bug_interactions_sign = as.data.frame(rbind(bug_interactions_sign,
                                                bug_interactions[bug_interactions$AntagConcRange<=multpTest_cutoff,]))
    
    bug_interactions_sign = bug_interactions_sign[grep(F,duplicated(bug_interactions_sign)),]
    bug_interactions_sign = bug_interactions_sign[!is.na(bug_interactions_sign[[1]]),]
    
    #synergy
    syn = bug_interactions_sign[bug_interactions_sign$bug_Q1 <= (-interac_cutoff),]
    syn = syn[syn$CompleteConcRange <= multpTest_cutoff,]
    syn_red =  bug_interactions_sign[bug_interactions_sign$bug_Q1_reduced <= (-interac_cutoff),]
    syn_red = syn_red[syn_red$SynConcRange <= multpTest_cutoff,]
    
    complt_specific = grep(F,row.names(syn) %in% row.names(syn_red))
    hit_classif = rep("both",length(syn[[1]]))
    hit_classif[complt_specific] = "complete_specific"
    syn = as.data.frame(cbind(syn,hit_classif))
    
    reduce_specific = grep(F,row.names(syn_red) %in% row.names(syn))
    hit_classif = rep("both",length(syn_red[[1]]))
    hit_classif[reduce_specific] = "reduced_specific"
    syn_red = as.data.frame(cbind(syn_red,hit_classif))
    
    syn = as.data.frame(rbind(syn,syn_red))
    syn = syn[grep(F,duplicated(syn)),]
    syn = syn[!is.na(syn[[1]]),]
    syn = as.data.frame(cbind(syn,rep("Synergy",length(syn[[1]]))))
    names(syn)[length(syn)] = c("direction")
    rm(syn_red)
    
    #antagonism
    antag = bug_interactions_sign[bug_interactions_sign$bug_Q3 >= (interac_cutoff),]
    antag = antag[antag$CompleteConcRange <= multpTest_cutoff,]
    antag_red = bug_interactions_sign[bug_interactions_sign$bug_Q3_reduced >= (interac_cutoff),]
    antag_red = antag_red[antag_red$AntagConcRange <= multpTest_cutoff,]
    
    complt_specific = grep(F,row.names(antag) %in% row.names(antag_red))
    hit_classif = rep("both",length(antag[[1]]))
    hit_classif[complt_specific] = "complete_specific"
    antag = as.data.frame(cbind(antag,hit_classif))
    
    reduce_specific = grep(F,row.names(antag_red) %in% row.names(antag))
    hit_classif = rep("both",length(antag_red[[1]]))
    hit_classif[reduce_specific] = "reduced_specific"
    antag_red = as.data.frame(cbind(antag_red,hit_classif))
    
    antag = as.data.frame(rbind(antag,antag_red))
    antag = antag[grep(F,duplicated(antag)),]
    antag = antag[!is.na(antag[[1]]),]
    antag = as.data.frame(cbind(antag,rep("Antagonism",length(antag[[1]]))))
    names(antag)[length(antag)] = c("direction")
    rm(antag_red)
    
    #Check for combinations with both antag & syn and remove from both
    opposite_int = row.names(antag)[grep(T,row.names(antag) %in% row.names(syn))]
    if(length(opposite_int)>0)
    {
      if(opposite_control==T)
      {
        antag = antag[-match(opposite_int,row.names(antag)),]
        syn = syn[-match(opposite_int,row.names(syn)),]
      } else
      {antag = antag[-match(opposite_int,row.names(antag)),]}
    }
    
    #Create a single table with interactions per bug
    bug_hits = as.data.frame(rbind(syn,antag))
    if(b==1)
    {Bugs_hits = list()}
    Bugs_hits[[length(Bugs_hits)+1]] = bug_hits
    
  }
  names(Bugs_hits) = names(Interaction_Qs)
  
  #clean up
  rm(bug_hits,bug_interactions,bug_interactions_sign,b,syn,antag,opposite_int)
  
  #============== Restrict to reduced/complete range ===========
  
  for(b in 1:length(Bugs_hits))
  {
    bug_hits = Bugs_hits[[b]]
    
    hit_classif = as.character(bug_hits$hit_classif)
    range_classification_counts = table(hit_classif)
    
    if(range == "complete" && length(grep("reduced_specific",hit_classif))>0)
    {bug_hits = bug_hits[-grep("reduced_specific",hit_classif),]}
    if(range == "reduced" && length(grep("complete_specific",hit_classif))>0)
    {bug_hits = bug_hits[-grep("complete_specific",hit_classif),]}
    
    Bugs_hits[[b]] = bug_hits
    
    if(b==1)
    {Range_classification_counts = list()}
    Range_classification_counts[[length(Range_classification_counts)+1]] = range_classification_counts
    
  }
  names(Range_classification_counts) = names(Bugs_hits)
  #=============== Count detectable synergy & antagonism ====================
  
  for(b in 1:length(P_values))
  {
    bug = names(P_values)[b]
    bug_pvals = P_values[[b]]
    
    min_wells = min(bug_pvals[grep(T,bug_pvals$Antag_p_val <= multpTest_cutoff),4])
    possible_antagonsim = length(bug_pvals[(bug_pvals$Pos_pot >= min_wells),1])
    min_wells = min(bug_pvals[grep(T,bug_pvals$Syn_p_val <= multpTest_cutoff),5])
    possible_synergy = length(bug_pvals[(bug_pvals$Neg_pot >= min_wells),1])
    
    detectable_syn_antag = as.data.frame(c(possible_synergy,possible_antagonsim))
    row.names(detectable_syn_antag) = c("detectableSyn","detectableAntag")
    names(detectable_syn_antag) = bug
    
    if(b==1)
    {DetectSynAntag = detectable_syn_antag} else
    {DetectSynAntag = as.data.frame(cbind(DetectSynAntag,detectable_syn_antag))}
  }
  DetectSynAntag = as.data.frame(t(DetectSynAntag))
  #clean up
  rm(b,bug_pvals,min_wells,possible_antagonsim,possible_synergy,detectable_syn_antag)
  
  #=============== Conservation within species ================
  for(sp in 1:length(Multi_Species))
  {
    species = Multi_Species[sp]
    bugs = Species_strains[[match(species,names(Species_strains))]]
    bug1 = bugs[1]
    bug2 = bugs[2] 
    
    bug1_interac = Interaction_Qs[[match(bug1,names(Interaction_Qs))]]
    bug2_interac = Interaction_Qs[[match(bug2,names(Interaction_Qs))]]
    
    bug1_expFit=Exp_fit_dist[[match(bug1,names(Exp_fit_dist))]]
    bug2_expFit=Exp_fit_dist[[match(bug2,names(Exp_fit_dist))]]
    
    bug1_hits = Bugs_hits[[grep(bug1,names(Bugs_hits))]]
    bug2_hits = Bugs_hits[[grep(bug2,names(Bugs_hits))]]
    all_hits = unique(c(row.names(bug1_hits),row.names(bug2_hits)))
    
    #new - took reduced Q1 and Q3 - only relevant expfit wells
    bug1_hits_restruct = bug1_hits[c(grep("Syn",bug1_hits$direction),grep("Antag",bug1_hits$direction)),]
    interac_score = c(bug1_hits[grep("Syn",bug1_hits$direction),match("bug_Q1_reduced",names(bug1_hits))],
                      bug1_hits[grep("Antag",bug1_hits$direction),match("bug_Q3_reduced",names(bug1_hits))])
    bug1_hits_restruct = as.data.frame(cbind(bug1_hits_restruct,interac_score))  
    bug1_hits_restruct = bug1_hits_restruct[match(c("direction","interac_score"),names(bug1_hits_restruct))]
    
    bug2_hits_restruct = bug2_hits[c(grep("Syn",bug2_hits$direction),grep("Antag",bug2_hits$direction)),]
    interac_score = c(bug2_hits[grep("Syn",bug2_hits$direction),match("bug_Q1_reduced",names(bug2_hits))],
                      bug2_hits[grep("Antag",bug2_hits$direction),match("bug_Q3_reduced",names(bug2_hits))])
    bug2_hits_restruct = as.data.frame(cbind(bug2_hits_restruct,interac_score))  
    bug2_hits_restruct = bug2_hits_restruct[match(c("direction","interac_score"),names(bug2_hits_restruct))]
    
    dir_bug1 = rep(NA,length(all_hits))
    dir_bug2 = rep(NA,length(all_hits))
    int_score_bug1 = rep(NA,length(all_hits))
    int_score_bug2 = rep(NA,length(all_hits))
    
    dir_bug1[match(row.names(bug1_hits_restruct),all_hits)] = as.character(bug1_hits_restruct[[1]])
    dir_bug2[match(row.names(bug2_hits_restruct),all_hits)] = as.character(bug2_hits_restruct[[1]])
    int_score_bug1[match(row.names(bug1_hits_restruct),all_hits)] = bug1_hits_restruct[[2]]
    int_score_bug2[match(row.names(bug2_hits_restruct),all_hits)] = bug2_hits_restruct[[2]]
    
    species_conserved = as.data.frame(cbind(dir_bug1,dir_bug2,int_score_bug1,int_score_bug2))
    row.names(species_conserved) = all_hits
    
    #Assess conservation
    conserved = rep("not_conserved",length(all_hits)) 
    conserved[grep(T,dir_bug1 == dir_bug2)] = "conserved"
    conserved[grep(paste0("Antagonism","Synergy"),paste0(dir_bug1,dir_bug2))] = "specific"
    conserved[grep(paste0("Synergy","Antagonism"),paste0(dir_bug1,dir_bug2))] = "specific"
    
    #Find integraction scores for weak interactions
    #bug1
    strong_bug1 = row.names(species_conserved)[grep(T,is.na(species_conserved$dir_bug2))]
    strong_bug1_bug2 = bug2_interac[match(strong_bug1,row.names(bug2_interac)),1:2]
    strong_bug1_interac_bug2 = strong_bug1_bug2[[2]]
    strong_bug1_interac_bug2[grep(T,abs(strong_bug1_bug2[[1]]) > abs(strong_bug1_bug2[[2]]))] = strong_bug1_bug2[grep(T,abs(strong_bug1_bug2[[1]]) > abs(strong_bug1_bug2[[2]])),1]
    
    int_score_bug2 = as.numeric(as.vector(species_conserved[[4]]))
    int_score_bug2[match(strong_bug1,row.names(species_conserved))] = strong_bug1_interac_bug2
    species_conserved[4] = int_score_bug2
    rm(strong_bug1,strong_bug1_bug2,strong_bug1_interac_bug2)
    
    #bug2
    strong_bug2 = row.names(species_conserved)[grep(T,is.na(species_conserved$dir_bug1))]
    strong_bug2_bug1 = bug1_interac[match(strong_bug2,row.names(bug1_interac)),1:2]
    strong_bug2_interac_bug1 = strong_bug2_bug1[[2]]
    strong_bug2_interac_bug1[grep(T,abs(strong_bug2_bug1[[1]]) > abs(strong_bug2_bug1[[2]]))] = strong_bug2_bug1[grep(T,abs(strong_bug2_bug1[[1]]) > abs(strong_bug2_bug1[[2]])),1]
    
    int_score_bug1 = as.numeric(as.vector(species_conserved[[3]]))
    int_score_bug1[match(strong_bug2,row.names(species_conserved))] = strong_bug2_interac_bug1
    species_conserved[3] = int_score_bug1
    rm(strong_bug2,strong_bug2_bug1,strong_bug2_interac_bug1)
    
    #Synergy
    strong_bug1_syn = species_conserved[grep("Syn",species_conserved$dir_bug1),]
    weak_conserved_syn_b2 = strong_bug1_syn[grep(T,strong_bug1_syn$int_score_bug2 <= (-weak_interac_cutoff)),]
    weak_conserved_syn_b2 = weak_conserved_syn_b2[grep(T,is.na(weak_conserved_syn_b2$dir_bug2)),]
    strong_bug2_syn = species_conserved[grep("Syn",species_conserved$dir_bug2),]
    weak_conserved_syn_b1 = strong_bug2_syn[grep(T,strong_bug2_syn$int_score_bug1 <= (-weak_interac_cutoff)),]
    weak_conserved_syn_b1 = weak_conserved_syn_b1[grep(T,is.na(weak_conserved_syn_b1$dir_bug1)),]
    
    weak_conserved_syn = c(row.names(weak_conserved_syn_b1),row.names(weak_conserved_syn_b2))
    conserved[match(weak_conserved_syn,all_hits)] = "weak_conserved"
    rm(strong_bug1_syn,weak_conserved_syn_b2,strong_bug2_syn,weak_conserved_syn_b1,weak_conserved_syn)
    
    #Antagonism
    strong_bug1_antag = species_conserved[grep("Antag",species_conserved$dir_bug1),]
    weak_conserved_antag_b2 = strong_bug1_antag[grep(T,strong_bug1_antag$int_score_bug2 >= (weak_interac_cutoff)),]
    weak_conserved_antag_b2 = weak_conserved_antag_b2[grep(T,is.na(weak_conserved_antag_b2$dir_bug2)),]
    strong_bug2_antag = species_conserved[grep("Antag",species_conserved$dir_bug2),]
    weak_conserved_antag_b1 = strong_bug2_antag[grep(T,strong_bug2_antag$int_score_bug1 >= (weak_interac_cutoff)),]
    weak_conserved_antag_b1 = weak_conserved_antag_b1[grep(T,is.na(weak_conserved_antag_b1$dir_bug1)),]
    
    weak_conserved_antag = c(row.names(weak_conserved_antag_b1),row.names(weak_conserved_antag_b2))
    conserved[match(weak_conserved_antag,all_hits)] = "weak_conserved"
    rm(strong_bug1_antag,weak_conserved_antag_b2,strong_bug2_antag,weak_conserved_antag_b1,weak_conserved_antag)
    
    #Find non-comparable interactions
    not_conserved_combs = all_hits[grep("not_conserved",conserved)]
    sp_p_vals = c()
    for(c in 1:length(bug1_expFit))
    {
      comb = names(bug1_expFit)[c]
      comb_expfit_bug1 = bug1_expFit[[c]]
      comb_expfit_bug2 = bug2_expFit[[match(comb,names(bug2_expFit))]]
      
      WT = wilcox.test(comb_expfit_bug1,comb_expfit_bug2)
      p_val = WT$p.value
      sp_p_vals = c(sp_p_vals,p_val)
      
    }
    sp_p_vals_BH = p.adjust(sp_p_vals,"BH")
    
    not_conserved_pvals = as.data.frame(sp_p_vals_BH[match(not_conserved_combs,names(bug1_expFit))])
    row.names(not_conserved_pvals) = not_conserved_combs
    names(not_conserved_pvals) = "Hits_pvals_BH"
    
    not_comparable = row.names(not_conserved_pvals)[grep(T,not_conserved_pvals[[1]] <= 0.05)]
    conserved[match(not_comparable,all_hits)] = "not_comparable"
    
    #Assign specific interactions
    conserved[grep(paste0("Antagonism","Synergy"),paste0(dir_bug1,dir_bug2))] = "specific"
    conserved[grep(paste0("Synergy","Antagonism"),paste0(dir_bug1,dir_bug2))] = "specific"
    
    species_conserved = as.data.frame(cbind(species_conserved,conserved))
    species_conserved = species_conserved[c(1,2,5,3,4)]
    
    if(sp==1)
    {Spieces_conservation = list()}
    Spieces_conservation[[length(Spieces_conservation)+1]] = species_conserved
    
    file_id = paste0(Out_dir,species,"_speciesInterac.txt")
    write.table(species_conserved,file_id,sep="\t",row.names=T,quote=FALSE,col.names = T)
  }
  names(Spieces_conservation) = Multi_Species
  
  #Count conservation and plot
  for(sp in 1:length(Multi_Species))
  {
    species = Multi_Species[sp]
    bugs = Species_strains[[match(species,names(Species_strains))]]
    
    sp_conser_table = Spieces_conservation[[sp]]
    
    sp_counts = c(length(grep_exact("conserved",sp_conser_table[[3]])),
                  length(grep_exact("weak_conserved",sp_conser_table[[3]])),
                  length(grep_exact("specific",sp_conser_table[[3]])),
                  length(grep_exact("not_conserved",sp_conser_table[[3]])),
                  length(grep_exact("not_comparable",sp_conser_table[[3]]))
    )
    
    sp_counts = as.data.frame(t(sp_counts))
    names(sp_counts) = c("Conserved","Weak conserved","Specific","Not conserved","Not comparable")
    row.names(sp_counts) = species
    
    if(sp==1)
    {Strain_comp_counts = sp_counts} else
    {Strain_comp_counts = as.data.frame(rbind(Strain_comp_counts,sp_counts))}
    
    #plot
    int_score_bug1 = sp_conser_table$int_score_bug1
    int_score_bug2 = sp_conser_table$int_score_bug2
    conserved = sp_conser_table$conserved
    
  }
  
  #======== Absolute counts for all bugs ===========
  flag=0
  for(sp in 1:length(Multi_Species))
  {
    species = Multi_Species[sp]
    sp_hits = Spieces_conservation[[sp]]
    
    keys = c(paste0("Antagonism","_","conserved"),paste0("Synergy","_","conserved"),
             paste0("Antagonism","_","weak_conserved"),paste0("Synergy","_","weak_conserved"),
             paste0("Antagonism","_","not_conserved"),paste0("Synergy","_","not_conserved"),
             paste0("Antagonism","_","specific"),paste0("Synergy","_","specific"),
             paste0("Antagonism","_","not_comparable"),paste0("Synergy","_","not_comparable")
    )
    
    #for b=1
    bug = unlist(Species_strains[[sp]])[1]
    temp = paste0(sp_hits[[1]],"_",sp_hits[[3]])
    
    absolute_counts = c()
    for(k in 1:length(keys))
    {
      key = keys[k]
      absolute_counts = c(absolute_counts,length(grep_exact(key,temp)))
    }
    
    absolute_counts = as.data.frame((absolute_counts))
    names(absolute_counts)=bug
    row.names(absolute_counts) = keys
    
    if(sp == 1 && flag==0)
    {Abs_counts = absolute_counts} else
    {Abs_counts = as.data.frame(cbind(Abs_counts,absolute_counts))}
    flag=1
    
    #for b=2
    bug = unlist(Species_strains[[sp]])[2]
    temp = paste0(sp_hits[[2]],"_",sp_hits[[3]])
    
    absolute_counts = c()
    for(k in 1:length(keys))
    {
      key = keys[k]
      absolute_counts = c(absolute_counts,length(grep_exact(key,temp)))
    }
    
    absolute_counts = as.data.frame((absolute_counts))
    names(absolute_counts)=bug
    row.names(absolute_counts) = keys
    
    Abs_counts = as.data.frame(cbind(Abs_counts,absolute_counts))
    
  }
  rm(flag,keys,bug,temp,sp,b,absolute_counts,species,sp_hits)
  
  Abs_counts[grep("Antagonism_weak_conserved",row.names(Abs_counts)),1:2] = sum(Abs_counts[grep("Antagonism_weak_conserved",row.names(Abs_counts)),1:2])
  Abs_counts[grep("Antagonism_weak_conserved",row.names(Abs_counts)),3:4] = sum(Abs_counts[grep("Antagonism_weak_conserved",row.names(Abs_counts)),3:4])
  Abs_counts[grep("Antagonism_weak_conserved",row.names(Abs_counts)),5:6] = sum(Abs_counts[grep("Antagonism_weak_conserved",row.names(Abs_counts)),5:6])
  Abs_counts[grep("Synergy_weak_conserved",row.names(Abs_counts)),1:2] = sum(Abs_counts[grep("Synergy_weak_conserved",row.names(Abs_counts)),1:2])
  Abs_counts[grep("Synergy_weak_conserved",row.names(Abs_counts)),3:4] = sum(Abs_counts[grep("Synergy_weak_conserved",row.names(Abs_counts)),3:4])
  Abs_counts[grep("Synergy_weak_conserved",row.names(Abs_counts)),5:6] = sum(Abs_counts[grep("Synergy_weak_conserved",row.names(Abs_counts)),5:6])
  
  #*********************Count by interactions sign (Anatagonism & Synergy)
  
  Total_probed_ns = unlist(lapply(Interac_distrib,FUN=length))
  hit_rates = sapply(Abs_counts,FUN=sum)/Total_probed_ns
  
  hit_rates_species = as.data.frame(c(sum(sapply(Abs_counts,FUN=sum)[1:2])/sum(Total_probed_ns[1:2]), #EC
                                      sum(sapply(Abs_counts,FUN=sum)[3:4])/sum(Total_probed_ns[3:4]), #ST
                                      sum(sapply(Abs_counts,FUN=sum)[5:6])/sum(Total_probed_ns[5:6]))) #PA
  row.names(hit_rates_species) = Multi_Species
  names(hit_rates_species) = "hit_rates_species"
  
  Total_syn = sum(as.matrix(as.vector(Abs_counts[grep("Syn",row.names(Abs_counts)),])))
  Total_antag = sum(as.matrix(as.vector(Abs_counts[grep("Antag",row.names(Abs_counts)),])))
  Total_antag_int = Total_syn+Total_antag
  
  #plot Total Syn and Antag over possible
  normalized_Syn_fraction = round(Total_syn/sum(DetectSynAntag[[1]]),3)
  normalized_Antag_fraction = round(Total_antag/sum(DetectSynAntag[[2]]),3)
  # barplot(c(normalized_Antag_fraction,normalized_Syn_fraction),
  #         beside=T,col=c(col_antagonism,col_synergy),ylim=c(0,0.16),las=2,
  #         main="Prevalent antagonism: Weak & Strong")
  # text(x=1.1,y=0.13,paste0("syn frac=",normalized_Syn_fraction),adj=0,col=col_synergy)
  # text(x=1.1,y=0.145,paste0("antag frac=",normalized_Antag_fraction),adj=0,col=col_antagonism)
  
  #Output tables
  Abs_counts_summary = as.data.frame(cbind(Total_probed_ns,sapply(Abs_counts,FUN=sum),hit_rates,
                                           sapply(Abs_counts[grep("Syn",row.names(Abs_counts)),],FUN=sum),
                                           sapply(Abs_counts[grep("Antag",row.names(Abs_counts)),],FUN=sum)))
  names(Abs_counts_summary)[c(2,4,5)] = c("Strong&weak_interactions","Synergy","Antagonism")
  Abs_counts_summary = as.data.frame(rbind(Abs_counts_summary,sapply(Abs_counts_summary,FUN=sum)))
  row.names(Abs_counts_summary)[7] = "Totals"
  Abs_counts_summary[7,3] = Abs_counts_summary[7,2]/Abs_counts_summary[7,1]
  
  DetectSynAntag = as.data.frame(cbind(DetectSynAntag,DetectSynAntag/Abs_counts_summary[1:6,1]))
  names(DetectSynAntag)[c(3,4)] = paste0("fraction_",names(DetectSynAntag)[c(3,4)])
  DetectSynAntag = as.data.frame(rbind(DetectSynAntag,sapply(DetectSynAntag,FUN=sum)))
  row.names(DetectSynAntag)[7] = "Totals"
  DetectSynAntag[7,3] = DetectSynAntag[7,1]/Abs_counts_summary[7,1]
  DetectSynAntag[7,4] = DetectSynAntag[7,2]/Abs_counts_summary[7,1]
  
  #***********************************Count by conservation
  Not_conserved = Abs_counts[grep("not_conserved",row.names(Abs_counts)),]
  Not_conserved = as.data.frame(rbind(Not_conserved,Abs_counts[grep("_specific",row.names(Abs_counts)),]))
  Abs_counts_blind = Abs_counts[c(1,3,5,7,9),]+Abs_counts[c(2,4,6,8,10),]
  Abs_counts_blind = as.data.frame(rbind(Abs_counts_blind,
                                         sapply(Abs_counts_blind,FUN=sum)))
  row.names(Abs_counts_blind) = c("conserved","weak_conserved","not_conserved","specific","not_comparable","total")
  
  #nr of strong interactions for at least 1 strain. Fig 3a&b, ED2
  ns_strong1strain = c(length(Spieces_conservation[[1]][,1]),length(Spieces_conservation[[1]][,1]),
                       length(Spieces_conservation[[2]][,1]),length(Spieces_conservation[[2]][,1]),
                       length(Spieces_conservation[[3]][,1]),length(Spieces_conservation[[3]][,1]))
  
  #Fractions of withihn species conserved/non-conserved interactions
  fraction_all_conserved = (Abs_counts_blind[1,]+Abs_counts_blind[2,])/ns_strong1strain
  fraction_all_conserved_corrected = (Abs_counts_blind[1,]+Abs_counts_blind[2,])/(ns_strong1strain-Abs_counts_blind[5,])
  fraction_all_non_conserved = (Abs_counts_blind[3,]+Abs_counts_blind[4,]+Abs_counts_blind[5,])/ns_strong1strain
  fraction_all_non_conserved_corrected = (Abs_counts_blind[3,]+Abs_counts_blind[4,])/(ns_strong1strain-Abs_counts_blind[5,])
  Conservation_fractions_strain = as.data.frame(rbind(fraction_all_conserved,fraction_all_conserved_corrected,
                                                      fraction_all_non_conserved,fraction_all_non_conserved_corrected,
                                                      ns_strong1strain))
  row.names(Conservation_fractions_strain) = c("Conserved/ns_strong1strain","Conserved/ns_strong1strain corrected",
                                               "Non-onserved/ns_strong1strain","Non-onserved/ns_strong1strain corrected",
                                               "ns_strong1strain")
  
  #Get all interactions
  flag=0
  for(sp in 1:length(Multi_Species))
  {
    species = Multi_Species[sp]
    sp_hits = Spieces_conservation[[sp]]
    
    #for b=1
    bug = unlist(Species_strains[[sp]])[1]
    bug1_int = sp_hits[grep(F,is.na(sp_hits[[1]])),]
    bug1_weak = sp_hits[grep_exact("weak_conserved",sp_hits[[3]]),]
    bug1_weak = bug1_weak[grep(T,is.na(bug1_weak[[1]])),]
    bug1_weak[1] = bug1_weak[2]
    bug1_int = as.data.frame(cbind(row.names(bug1_int),bug1_int))
    bug1_weak = as.data.frame(cbind(row.names(bug1_weak),bug1_weak))
    row.names(bug1_int) = c()
    row.names(bug1_weak) = c()
    names(bug1_int)[1] = "combination"
    names(bug1_weak)[1] = "combination"
    bug1_int = as.data.frame(rbind(bug1_int,bug1_weak))
    bug1_int = as.data.frame(cbind(bug1_int[c(1,2,4)],rep(bug,length(bug1_int[[1]]))))
    names(bug1_int)[c(2,4)] = c("direction","bug")
    
    if(flag==0)
    {
      Absolute_interactions = bug1_int
      flag=1
    } else
    {Absolute_interactions = as.data.frame(rbind(Absolute_interactions,bug1_int))}
    
    #for b=2
    bug = unlist(Species_strains[[sp]])[2]
    bug1_int = sp_hits[grep(F,is.na(sp_hits[[2]])),]
    bug1_weak = sp_hits[grep_exact("weak_conserved",sp_hits[[3]]),]
    bug1_weak = bug1_weak[grep(T,is.na(bug1_weak[[2]])),]
    bug1_weak[2] = bug1_weak[1]
    bug1_int = as.data.frame(cbind(row.names(bug1_int),bug1_int))
    bug1_weak = as.data.frame(cbind(row.names(bug1_weak),bug1_weak))
    row.names(bug1_int) = c()
    row.names(bug1_weak) = c()
    names(bug1_int)[1] = "combination"
    names(bug1_weak)[1] = "combination"
    bug1_int = as.data.frame(rbind(bug1_int,bug1_weak))
    bug1_int = as.data.frame(cbind(bug1_int[c(1,3,4)],rep(bug,length(bug1_int[[1]]))))
    names(bug1_int)[c(2,4)] = c("direction","bug")
    
    rm(bug1_weak)
    Absolute_interactions = as.data.frame(rbind(Absolute_interactions,bug1_int))
  }
  rm(flag)
  
  #*************add MAster class info
  drug_ints = as.vector(Absolute_interactions[[1]])
  
  drug1 = unlist(strsplit(drug_ints,split="_"))[seq(1,2*length(drug_ints),by=2)]
  drug2 = unlist(strsplit(drug_ints,split="_"))[seq(2,2*length(drug_ints),by=2)]
  
  class1 = get_feature(drug1,feature = "Master_Class",Attr_table)
  class2 = get_feature(drug2,feature = "Master_Class",Attr_table)
  
  ints_classes = paste0(class1,"_",class2)
  Absolute_interactions = as.data.frame(cbind(Absolute_interactions,ints_classes))
  rm(ints_classes,drug_ints,drug1,drug2,class1,class2)
  
  #*************add class info
  drug_ints = as.vector(Absolute_interactions[[1]])
  
  drug1 = unlist(strsplit(drug_ints,split="_"))[seq(1,2*length(drug_ints),by=2)]
  drug2 = unlist(strsplit(drug_ints,split="_"))[seq(2,2*length(drug_ints),by=2)]
  
  class1 = get_feature(drug1,feature = "Class",Attr_table)
  class2 = get_feature(drug2,feature = "Class",Attr_table)
  
  ints_classes = paste0(class1,"_",class2)
  Absolute_interactions = as.data.frame(cbind(Absolute_interactions,ints_classes))
  rm(ints_classes,drug_ints,drug1,drug2,class1,class2)
  
  names(Absolute_interactions) = c("combination","direction","conserved","bug","Master Class","Class")
  
  #========== Create Results_list =========
  
  nr_drugs_1int_per_bug = c()
  for(b in 1:length(unlist(Species_strains)))
  {
    bug = unlist(Species_strains)[b]
    bug_ints = Absolute_interactions[grep(bug,Absolute_interactions$bug),]
    
    if(length(row.names(bug_ints))>0)
    {
      combs = as.character(bug_ints[[1]])
      drug1 = unlist(strsplit(combs,split="_"))[seq(1,2*length(combs),by=2)]
      drug2 = unlist(strsplit(combs,split="_"))[seq(2,2*length(combs),by=2)]
      drugs12 = c(drug1,drug2)
    } else
    {drugs12 = c()}
    
    nr_drugs_1int_per_bug = c(nr_drugs_1int_per_bug,length(table(drugs12)))
  }
  
  
  Results_list = list(Abs_counts, #Total, Syn and Antag counts
                      Abs_counts_summary,
                      hit_rates_species,
                      DetectSynAntag, #Detectable Syn & Antagonism
                      Abs_counts_blind, #Conservation_within species
                      Conservation_fractions_strain, #Fractions of withihn species conserved/non-conserved interactions
                      nr_drugs_1int_per_bug,
                      Range_classification_counts,
                      Absolute_interactions #Interactions table
  )
  
  names(Results_list) = c("Abs_counts","Abs_counts_summary","hit_rates_species",
                          "Detectable_Syn_&_Antagonism",
                          "Conservation_within_species",
                          "Conservation_fractions_strain",
                          "nr_drugs_1int_per_bug",
                          "Range_classification_counts",
                          "Interactions_table")
  
  #============ Benchmark =========
  par(mfrow=c(1,1),mar=c(6,6,6,6))
  
  file_id = Benchmarking_file
  Benchmarking = read.table(file_id,sep="\t",header = T)
  
  Screen = rep(NA,length(Benchmarking[[1]]))
  Conservation = rep(NA,length(Benchmarking[[1]]))
  for(c in 1:length(Benchmarking[[1]]))
  {
    comb = as.character(Benchmarking$Combination[c])
    bug = as.character(Benchmarking$Strain[c])
    rev = as.character(Benchmarking$Reverse[c])
    
    sp_hits = Absolute_interactions[grep(bug,as.character(Absolute_interactions$bug)),]
    
    if(length(grep(comb,sp_hits$combination))>0)
    {Screen[c] = as.character(sp_hits[grep(comb,sp_hits$combination),2])}
    
    if(length(grep(rev,sp_hits$combination))>0)
    {Screen[c] = as.character(sp_hits[grep(rev,sp_hits$combination),2])}
    
    if(length(grep(comb,sp_hits$combination))>0)
    {Conservation[c] = as.character(sp_hits[grep(comb,sp_hits$combination),3])}
    
    if(length(grep(rev,sp_hits$combination))>0)
    {Conservation[c] = as.character(sp_hits[grep(rev,sp_hits$combination),3])}
  }
  
  Screen[grep("Antag",Screen)] = "A"
  Screen[grep("Syn",Screen)] = "S"
  Screen[grep(T,is.na(Screen))] = "N"
  
  Benchmarking = as.data.frame(cbind(Benchmarking,Screen,Conservation))
  Benchmarking = Benchmarking[c(1,2,3,6,4,5)]
  
  Hit_classif = rep(NA,length(Benchmarking[[1]]))
  dummy = paste0(as.character(Benchmarking$Benchmarking),as.character(Benchmarking$Screen))
  Hit_classif[grep("NN",dummy)]="TN"
  Hit_classif[grep("AA",dummy)]="TP"
  Hit_classif[grep("SS",dummy)]="TP"
  Hit_classif[grep("NS",dummy)]="FP"
  Hit_classif[grep("NA",dummy)]="FP"
  Hit_classif[grep("SN",dummy)]="FN"
  Hit_classif[grep("AN",dummy)]="FN"
  
  if(length(grep("AS",dummy))>0)
  {Hit_classif[grep("AS",dummy)]="FP"}
  if(length(grep("SA",dummy))>0)
  {Hit_classif[grep("SA",dummy)]="FP"}
  
  Benchmarking = as.data.frame(cbind(Benchmarking,Hit_classif))
  counts = table(Hit_classif)
  
  counts = as.data.frame(t(as.data.frame(t(counts)[1,])))
  Counts = as.data.frame(matrix(0,ncol = 4,nrow = 1))
  row.names(Counts)=NULL
  names(Counts) = c("TP","TN","FP","FN")
  
  Counts[match(names(counts),names(Counts))]=counts
  
  Precision = round(Counts$TP/(Counts$TP+Counts$FP),2)
  Recall = round(Counts$TP/(Counts$TP+Counts$FN),2)
  FPR = round(Counts$FP/(Counts$FP+Counts$TN),2)
  TPR = Recall
  
  nr_interac = Results_list$Abs_counts_summary
  nr_interac = nr_interac$`Strong&weak_interactions`
  nr_interac = nr_interac[length(nr_interac)]
  
  roc = as.data.frame(t(c(TPR,FPR,Precision,nr_interac)))
  names(roc) = c("TPR","FPR","Precision","total_ints")
  row.names(roc) = interac_cutoff
  row.names(Counts) = interac_cutoff
  
  roc = as.data.frame(cbind(roc,Counts))
  
  return(roc)
}
